---
description: 'Learn what Modules are and how can you use them during your custom development with Medusa.'
---

import DocCardList from '@theme/DocCardList';
import Icons from '@theme/Icon';

# How to Create a Module

In this document, you’ll learn how to create a module, test the module, publish it to NPM, and install it in a Medusa backend.

This document covers the general steps of creating an internal module, but does not explore actually implementing any functionality in it. An internal module is a module that extends or replaces a functionality within the Medusa backend, such as the cache or event bus functionality.

## Prerequisites

If you wish to follow the steps to publish the module on NPM, you’ll need an [NPM account](https://www.npmjs.com/signup) to publish the module on.

---

## Step 1: Create an NPM Project

Since modules are installed in the Medusa backend (or other NPM projects) using NPM, you must create an NPM project that will hold your module.

If you don’t have one already created, run the following commands to create a directory and initialize an NPM project in it:

```bash npm2yarn
mkdir my-module
npm init
```

You’ll be asked a couple of questions related to your package, such as its name or license. You can keep the default for now or set them right away.

Once you’re done, you should have a `package.json` created in the directory.

---

## Step 2: Changes to package.json

In your `package.json` file, add or update the following fields:

```json title=package.json
{
  // other fields
  "main": "dist/index.js",
  "publishConfig": {
    "access": "public"
  },
  "files": [
    "dist"
  ],
  "devDependencies": {
    "@medusajs/types": "^0.0.2",
    "cross-env": "^5.2.1",
    "typescript": "^4.4.4"
  },
  "scripts": {
    "watch": "tsc --build --watch",
    "prepare": "cross-env NODE_ENV=production npm run build",
    "build": "tsc --build",
  },
  "dependencies": {
    "@medusajs/modules-sdk": "^0.1.0",
  }
}
```

This adds the necessary dependencies for your development, including the `@medusajs/modules-sdk` package. It also adds the following scripts that will help you during your development of the module:

- `watch`: can be used to re-build your module whenever any changes occur without having to manually trigger the `build`.
- `prepare`: can be used to prepare your module for publishing on NPM
- `build`: can be used to manually build your module.

---

## Step 3: Add tsconfig.json

In the root of your NPM project, create the file `tsconfig.json` with the following content:

```json title=tsconfig.json
{
  "compilerOptions": {
    "lib": [
      "es2020"
    ],
    "target": "2020",
    "outDir": "./dist",
    "esModuleInterop": true,
    "declaration": true,
    "module": "commonjs",
    "moduleResolution": "node",
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "sourceMap": true,
    "noImplicitReturns": true,
    "strictNullChecks": true,
    "strictFunctionTypes": true,
    "noImplicitThis": true,
    "allowJs": true,
    "skipLibCheck": true,
  },
  "include": ["src"],
  "exclude": [
    "dist",
    "./src/**/__tests__",
    "./src/**/__mocks__",
    "./src/**/__fixtures__",
    "node_modules"
  ]
}
```

This allows you to use the recommended TypeScript configurations and sets the output directory to `dist`. This is essential for preparing your module for testing and publishing.

---

## Step 4: Implement the Custom Functionality

This step depends on what you’re actually implementing. For example, you can implement the cache or events module, or you can implement a commerce module. If what you’re creating has a guide, you can refer to it while implementing the functionalities.

<DocCardList colSize={6} items={[
  {
    type: 'link',
    href: '#',
    label: 'Create a Cache Module',
    customProps: {
      icon: Icons['academic-cap-solid'],
      description: 'Learn how to create a cache module in Medusa.',
      isSoon: true
    }
  },
  {
    type: 'link',
    href: '#',
    label: 'Create an Events Module',
    customProps: {
      icon: Icons['academic-cap-solid'],
      description: 'Learn how to create an events module in Medusa.',
      isSoon: true
    }
  },
]} />

---

### Step 5: Export Module

After implementing the module, you must export a module object that helps the Medusa backend understand how to use this Module. This is done in the file `src/index.ts`.

The file must export an object with the following properties:

```ts
type ModuleExports = {
  service: Constructor<any>
  loaders?: ModuleLoaderFunction[]
  migrations?: any[]
  models?: Constructor<any>[]
  runMigrations?(
    options: LoaderOptions,
    moduleDeclaration: InternalModuleDeclaration
  ): Promise<void>
  revertMigration?(
    options: LoaderOptions,
    moduleDeclaration: InternalModuleDeclaration
  ): Promise<void>
}
```

:::note

All property types such as `ModuleLoaderFunction` can be loaded from the `@medusajs/modules-sdk` package.

:::

Where:

- `service`: This is the only required property to be exported. It should be the main service your module exposes, and it must implement all the declared methods on the module interface. For example, if it's a cache module, it must implement  the `ICacheService` interface exported from `@medusajs/types`.
- `loaders`: (optional) an array of functions used to perform an action while loading the module. For example, you can log a message that the module has been loaded, or if your module's scope is [isolated](#module-scope) you can use the loader to establish a database connection.
- `migrations`: (optional) an array of objects containing database migrations that should run when the `migration` command is used with Medusa's CLI.
- `models`: (optional) an array of entities that your module creates.
- `runMigrations`: (optional) a function that can be used to define migrations to run when the `migration run` command is used with Medusa's CLI. The migrations will only run if they haven't already. This will only be executed if the module's scope is [isolated](#module-scope).
- `revertMigration`: (optional) a function can be used to define how migrations should be reverted when the `migration revert` command is used with Medusa's CLI. This will only be executed if the module's scope is [isolated](#module-scope).

Here's an example implementation of `src/index.ts` from Medusa's Redis Cache module:

```ts title=src/index.ts
import { ModuleExports } from "@medusajs/modules-sdk"

import Loader from "./loaders"
import { RedisCacheService } from "./services"

const service = RedisCacheService
const loaders = [Loader]

const moduleDefinition: ModuleExports = {
  service,
  loaders,
}

export default moduleDefinition
```

---

## Step 6: Test your Module

This step explains how you can test your module in a locally installed [Medusa backend](../backend/install.mdx) after or while implementing your custom functionality.

Run the following command in the root of your module directory:

```bash npm2yarn
npm run build
```

Then, register your package locally to use it in other NPM projects with the following command:

```bash npm2yarn
npm link
```

Next, in your Medusa backend, run the following command to install your module:

```bash npm2yarn
npm link module-name
```

Where `module-name` is the name of your module as defined in the `package.json` of your module.

Finally, add your module to `medusa-config.js`:

```js title=medusa-config.js
module.exports = {
  // ...
  modules: { 
    // ...
    moduleType: {
      resolve: "<module_name>", 
      options: {
        // options if necessary
      },
      // optional
      resources: "shared",
    },
  },
}
```

The way you add your module depends on its type and what options it requires, if any. Note that in the above code example:

- `moduleType` is the type of your module. For example, if your module is a cache module, it should be changed to `cacheService`.
- `<module_name>` is the name of your module as defined in the `package.json` of your module.
- `options` should hold any options of your module, if necessary.
- `resources` is an optional property that indicates whether the module shares the same dependency container as the rest of the resources in the Medusa backend. It can be one of the following values:
  - `shared`: (default) The dependency container is shared with the module, including the database connection. You don't need to establish the database connection yourself in a loader.
  - `isolated`: the module receives an empty dependency container, and only its own dependencies will be registered in the container. When using this value, you must establish the database connection yourself and managing other resources within your module.

You can now test it out simply by running the Medusa backend:

```bash npm2yarn
npm run start
```

### Module Scope

By default, the module shares the same dependency container used across the Medusa backend. So, the module can benefit from the core services and other resources available through [dependency injection](../fundamentals/dependency-injection.md). The module can also benefit from the same database connection.

The module's scope can be changed using the `resources` property available as part of the module's configurations:

```js title=medusa-config.js
module.exports = {
  // ...
  modules: { 
    // ...
    moduleType: {
      // other configurations
      resources: "shared",
    },
  },
}
```

The `resources` property can have one of the following values:

- `shared`: (default) The dependency container is shared with the module, including the database connection. You don't need to establish the database connection yourself in a loader.
- `isolated`: the module receives an empty dependency container, and only its own dependencies will be registered in the container. When using this value, you must establish the database connection yourself and managing other resources within your module.

---

## Step 7: Publish Module

This section explains how to publish your module to NPM.

### Run Prepare Command

Before you publish or update your module, make sure to run the `prepare` command defined earlier:

```bash npm2yarn
npm run prepare
```

### Login

In your terminal, log in with your NPM account:

```bash
npm login
```

You’ll be asked to enter your NPM email and password.

### Publish Module Package

Once you’re logged in, you can publish your package with the following command:

```bash
npm publish
```

Your package is then published on NPM and everyone can use it and install it.

### Install Module

To install your published module, you can run the following command on any Medusa backend project:

```bash
npm install module-name
```

Where `module-name` is the name of your module.

### Update Module

To update your module at a later point, you can run the following command to change the NPM version:

```bash
npm version <type>
```

Where `<type>` indicates the type of version update you’re publishing. For example, it can be `major` or `minor`. You can see the [full list of types in NPM’s documentation](https://docs.npmjs.com/cli/v8/commands/npm-version).

Then, publish the new update:

```bash
npm publish
```
