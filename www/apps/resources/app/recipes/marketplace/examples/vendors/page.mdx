import { Github, PlaySolid } from "@medusajs/icons"
import { Prerequisites } from "docs-ui"

export const metadata = {
  title: `Marketplace Recipe: Vendors Example`,
}

# {metadata.title}

This document provides an example of implementing the marketplace recipe.

<Note>

You can implement the marketplace as you see fit for your use case. This is only an example of one way to implement it.

</Note>

## Features

By following this example, you’ll have a marketplace with the following features:

1. Multiple vendors, each having vendor admins.
2. Vendor admins manage the vendor’s products and orders.
3. On order creation, the order is split into multiple orders for each vendor.
4. All other commerce features that Medusa provides.

<CardList items={[
  {
    href: "https://github.com/medusajs/examples/tree/main/marketplace",
    title: "Marketplace Example Repository",
    text: "Find the full code for this recipe example in this repository.",
    icon: Github,
  },
  {
    href: "https://res.cloudinary.com/dza7lstvk/raw/upload/v1720603521/OpenApi/Marketplace_OpenApi_n458oh.yml",
    title: "OpenApi Specs for Postman",
    text: "Imported this OpenApi Specs file into tools like Postman.",
    icon: PlaySolid,
  },
]} />

---

<Prerequisites items={[
  {
    text: "A new Medusa application installed.",
    link: "!docs!#get-started"
  },
]} />

## Step 1: Create Marketplace Module

The first step is to create a marketplace module that holds the data models for a vendor and an admin. 

Create the directory `src/modules/marketplace`.

### Create Data Models

Create the file `src/modules/marketplace/models/vendor.ts` with the following content:

```ts title="src/modules/marketplace/models/vendor.ts"
import { model } from "@medusajs/framework/utils"
import VendorAdmin from "./vendor-admin"

const Vendor = model.define("vendor", {
  id: model.id().primaryKey(),
  handle: model.text(),
  name: model.text(),
  logo: model.text().nullable(),
  admins: model.hasMany(() => VendorAdmin),
})

export default Vendor
```

This creates a `Vendor` data model, which represents a business that sells its products in the marketplace.

Notice that the `Vendor` has many admins whose data model you’ll create next.

Create the file `src/modules/marketplace/models/vendor-admin.ts` with the following content:

```ts title="src/modules/marketplace/models/vendor-admin.ts"
import { model } from "@medusajs/framework/utils"
import Vendor from "./vendor"

const VendorAdmin = model.define("vendor_admin", {
  id: model.id().primaryKey(),
  first_name: model.text().nullable(),
  last_name: model.text().nullable(),
  email: model.text().unique(),
  vendor: model.belongsTo(() => Vendor, {
    mappedBy: "admins",
  }),
})

export default VendorAdmin
```

This creates a `VendorAdmin` data model, which represents an admin of a vendor.

### Create Main Module Service

Next, create the main service of the module at `src/modules/marketplace/service.ts` with the following content:

```ts title="src/modules/marketplace/service.ts"
import { MedusaService } from "@medusajs/framework/utils"
import Vendor from "./models/vendor"
import VendorAdmin from "./models/vendor-admin"

class MarketplaceModuleService extends MedusaService({
  Vendor,
  VendorAdmin,
}) {
}

export default MarketplaceModuleService
```

The service extends the [service factory](!docs!/learn/advanced-development/modules/service-factory), which provides basic data-management features.

### Create Module Definition

After that, create the module definition at `src/modules/marketplace/index.ts` with the following content:

```ts title="src/modules/marketplace/index.ts"
import { Module } from "@medusajs/framework/utils"
import MarketplaceModuleService from "./service"

export const MARKETPLACE_MODULE = "marketplaceModuleService"

export default Module(MARKETPLACE_MODULE, {
  service: MarketplaceModuleService,
})
```

### Add Module to Medusa Configuration

Finally, add the module to the list of modules in `medusa-config.ts`:

```ts title="medusa-config.ts"
module.exports = defineConfig({
  // ...
  modules: [
    {
      resolve: "./src/modules/marketplace",
    },
  ]
})
```

### Further Reads

- [How to Create a Module](!docs!/learn/basics/modules)
- [How to Create Data Models](!docs!/learn/basics/modules#1-create-data-model)

---

## Step 2: Define Links to Product and Order Data Models

Each vendor has products and orders. So, in this step, you’ll define links between the `Vendor` data model and the `Product` and `Order` data models from the Product and Order modules, respectively.

<Note title="Tip">

If your use case requires linking the vendor to other data models, such as `SalesChannel`, define those links in a similar manner.

</Note>

Create the file `src/links/vendor-product.ts` with the following content:

```ts title="src/links/vendor-product.ts"
import { defineLink } from "@medusajs/framework/utils"
import MarketplaceModule from "../modules/marketplace"
import ProductModule from "@medusajs/medusa/product"

export default defineLink(
  MarketplaceModule.linkable.vendor,
  {
    linkable: ProductModule.linkable.product,
    isList: true,
  }
)
```

This adds a list link between the `Vendor` and `Product` data models, indicating that a vendor record can be linked to many product records.

Then, create the file `src/links/vendor-order.ts` with the following content:

```ts title="src/links/vendor-order.ts"
import { defineLink } from "@medusajs/framework/utils"
import MarketplaceModule from "../modules/marketplace"
import OrderModule from "@medusajs/medusa/order"

export default defineLink(
  MarketplaceModule.linkable.vendor,
  {
    linkable: OrderModule.linkable.order,
    isList: true,
  }
)
```

This adds a list link between the `Vendor` and `Order` data models, indicating that a vendor record can be linked to many order records.

### Further Read

- [How to Define Module Links](!docs!/learn/advanced-development/module-links)

---

## Step 3: Run Migrations and Sync Links

To create tables for the marketplace data models in the database, start by generating the migrations for the Marketplace Module with the following command:

```bash
npx medusa db:generate marketplaceModuleService
```

This generates a migration in the `src/modules/marketeplace/migrations` directory.

Then, to reflect the migration and links in the database, run the following command:

```bash
npx medusa db:migrate
```

---

## Step 4: Create Vendor Admin Workflow

In this step, you’ll create the workflow used to create a vendor admin.

The workflow’s steps are:

1. Create the vendor admin using the Marketplace Module’s main service.
2. Create a `vendor` [actor type](../../../../commerce-modules/auth/auth-identity-and-actor-types/page.mdx) to authenticate the vendor admin using the Auth Module. Medusa provides a step to perform this.

First, create the file `src/workflows/marketplace/create-vendor-admin/steps/create-vendor-admin.ts` with the following content:

export const createVendorAdminStepHighlights = [
  ["24", "vendorAdmin", "Pass the created vendor admin to the compensation function."]
]

```ts title="src/workflows/marketplace/create-vendor-admin/steps/create-vendor-admin.ts" highlights={createVendorAdminStepHighlights} collapsibleLines="1-8" expandMoreLabel="Show Imports"
import { 
  createStep,
  StepResponse,
} from "@medusajs/framework/workflows-sdk"
import { CreateVendorAdminWorkflowInput } from ".."
import MarketplaceModuleService from "../../../../modules/marketplace/service"
import { MARKETPLACE_MODULE } from "../../../../modules/marketplace"

const createVendorAdminStep = createStep(
  "create-vendor-admin-step",
  async ({ 
    admin: adminData,
  }: Pick<CreateVendorAdminWorkflowInput, "admin">, 
  { container }) => {
    const marketplaceModuleService: MarketplaceModuleService = 
      container.resolve(MARKETPLACE_MODULE)

    const vendorAdmin = await marketplaceModuleService.createVendorAdmins(
      adminData
    )

    return new StepResponse(
      vendorAdmin,
      vendorAdmin
    )
  },
  async (vendorAdmin, { container }) => {
    const marketplaceModuleService: MarketplaceModuleService = 
      container.resolve(MARKETPLACE_MODULE)

    marketplaceModuleService.deleteVendorAdmins(vendorAdmin.id)
  }
)

export default createVendorAdminStep
```

This is the first step that creates the vendor admin and returns it.

In the compensation function, which runs if an error occurs in the workflow, it removes the admin.

Then, create the workflow at `src/workflows/marketplace/create-vendor-admin/index.ts` with the following content:

export const vendorAdminWorkflowHighlights = [
  ["23", "createVendorAdminStep", "Create the vendor admin."],
  ["27", "setAuthAppMetadataStep", "Step is imported from `@medusajs/medusa/core-flows`."]
]

```ts title="src/workflows/marketplace/create-vendor-admin/index.ts" highlights={vendorAdminWorkflowHighlights}
import { 
  createWorkflow,
  WorkflowResponse,
} from "@medusajs/framework/workflows-sdk"
import { 
  setAuthAppMetadataStep,
} from "@medusajs/medusa/core-flows"
import createVendorAdminStep from "./steps/create-vendor-admin"

export type CreateVendorAdminWorkflowInput = {
  admin: {
    email: string
    first_name?: string
    last_name?: string
    vendor_id: string
  }
  authIdentityId: string
}

const createVendorAdminWorkflow = createWorkflow(
  "create-vendor-admin",
  function (input: CreateVendorAdminWorkflowInput) {
    const vendorAdmin = createVendorAdminStep({
      admin: input.admin,
    })

    setAuthAppMetadataStep({
      authIdentityId: input.authIdentityId,
      actorType: "vendor",
      value: vendorAdmin.id,
    })

    return new WorkflowResponse(vendorAdmin)
  }
)

export default createVendorAdminWorkflow
```

In this workflow, you run the following steps:

1. `createVendorAdminStep` to create the vendor admin.
2. `setAuthAppMetadataStep` to create the `vendor` actor type. This step is provided by Medusa in the `@medusajs/medusa/core-flows` package.

You return the created vendor admin.

### Further Read

- [How to Create a Workflow](!docs!/learn/basics/workflows)
- [What is an Actor Type](../../../../commerce-modules/auth/auth-identity-and-actor-types/page.mdx)
- [How to Create an Actor Type](../../../../commerce-modules/auth/create-actor-type/page.mdx)
- [What is a Compensation Function](!docs!/learn/advanced-development/workflows/compensation-function)

---

## Step 5: Create Vendor API Route

In this step, you’ll create the API route that runs the workflow from the previous step.

Start by creating the file `src/api/vendors/route.ts` with the following content:

export const vendorRouteSchemaHighlights = [
  ["10", "schema", "Define the fields expected in the request body."],
]

```ts title="src/api/vendors/route.ts" highlights={vendorRouteSchemaHighlights}
import { 
  AuthenticatedMedusaRequest, 
  MedusaResponse,
} from "@medusajs/framework/http"
import { MedusaError } from "@medusajs/framework/utils"
import { z } from "zod"
import MarketplaceModuleService from "../../modules/marketplace/service"
import createVendorAdminWorkflow from "../../workflows/marketplace/create-vendor-admin"

const schema = z.object({
  name: z.string(),
  handle: z.string().optional(),
  logo: z.string().optional(),
  admin: z.object({
    email: z.string(),
    first_name: z.string().optional(),
    last_name: z.string().optional(),
  }).strict(),
}).strict()

type RequestBody = {
  name: string,
  handle?: string,
  logo?: string,
  admin: {
    email: string,
    first_name?: string,
    last_name?: string
  }
}

```

This defines the schema to be accepted in the request body.

Then, add the route handler to the same file:

export const vendorRouteHighlights = [
  ["14", "parse", "Validate the request body and, if valid, retrieve it as an object."],
  ["20", "createVendors", "Create the vendor using the Marketplace Module's main service."],
  ["23", "createVendorAdminWorkflow", "Execute the workflow created in the first step."],
]

```ts title="src/api/vendors/route.ts" highlights={vendorRouteHighlights}
export const POST = async (
  req: AuthenticatedMedusaRequest<RequestBody>,
  res: MedusaResponse
) => {
  // If `actor_id` is present, the request carries 
  // authentication for an existing vendor admin
  if (req.auth_context?.actor_id) {
    throw new MedusaError(
      MedusaError.Types.INVALID_DATA,
      "Request already authenticated as a vendor."
    )
  }

  const { admin, ...vendorData } = schema.parse(req.body) as RequestBody

  const marketplaceModuleService: MarketplaceModuleService = req.scope
    .resolve("marketplaceModuleService")

  // create vendor
  let vendor = await marketplaceModuleService.createVendors([vendorData])

  // create vendor admin
  await createVendorAdminWorkflow(req.scope)
    .run({
      input: {
        admin: {
          ...admin,
          vendor_id: vendor[0].id,
        },
        authIdentityId: req.auth_context.auth_identity_id,
      },
    })

  // retrieve vendor again with admins
  vendor = await marketplaceModuleService.retrieveVendor(vendor[0].id, {
    relations: ["admins"],
  })

  res.json({
    vendor,
  })
}
```

This API route expects the request header to contain a new vendor admin’s authentication JWT token.

The route handler creates a vendor using the Marketplace Module’s main service and then uses the `createVendorAdminWorkflow` to create an admin for the vendor.

Next, create the file `src/api/middlewares.ts` with the following content:

```ts title="src/api/middlewares.ts"
import { 
  defineMiddlewares,
  authenticate,
} from "@medusajs/medusa"

export default defineMiddlewares({
  routes: [
    {
      matcher: "/vendors",
      method: "POST",
      middlewares: [
        authenticate("vendor", ["session", "bearer"], {
          allowUnregistered: true,
        }),
      ],
    },
    {
      matcher: "/vendors/*",
      middlewares: [
        authenticate("vendor", ["session", "bearer"]),
      ],
    },
  ],
})
```

This applies two middlewares:

1. On the `/vendors` POST API route; it requires authentication but allows unregistered users.
2. On the `/vendors/*` API routes, which you’ll implement in upcoming sections; it requires an authenticated vendor admin.

### Test it Out

To test out the above API route:

1. Start the Medusa application:

```bash npm2yarn
npm run dev
```

2. Retrieve a JWT token from the `/auth/vendor/emailpass/register` API route:

```bash apiTesting testApiUrl="http://localhost:9000/auth/vendor/emailpass/register" testApiMethod="POST" testBodyParams={{ "email": "admin@medusa-test.com", "password": "supersecret" }}
curl -X POST 'http://localhost:9000/auth/vendor/emailpass/register' \
-H 'Content-Type: application/json' \
--data-raw '{
    "email": "admin@medusa-test.com",
    "password": "supersecret"
}'
```

<Note title="Tip">

This route is available because you created the `vendor` actor type previously.

</Note>

3. Send a request to the `/vendors` API route, passing the token retrieved from the previous response in the request header:

<Note>

Don't include a trailing slash at the end of the URL. Learn more [here](!docs!/learn/advanced-development/api-routes/middlewares).

</Note>

```bash
curl -X POST 'http://localhost:9000/vendors' \
-H 'Content-Type: application/json' \
-H 'Authorization: Bearer {token}' \
--data-raw '{
    "name": "Acme",
    "handle": "acme",
    "admin": {
        "email": "admin@medusa-test.com",
        "first_name": "Admin",
        "last_name": "Acme"
    }
}'
```

This returns the created vendor and admin.

4. Retrieve an authenticated token of the vendor admin by sending another request to the `/auth/vendor/emailpass` API route:

```bash apiTesting testApiUrl="http://localhost:9000/auth/vendor/emailpass" testApiMethod="POST" testBodyParams={{ "email": "admin@medusa-test.com", "password": "supersecret" }}
curl -X POST 'http://localhost:9000/auth/vendor/emailpass' \
-H 'Content-Type: application/json' \
--data-raw '{
    "email": "admin@medusa-test.com",
    "password": "supersecret"
}'
```

Use this token in the header of later requests that require authentication.

### Further Reads

- [How to Create an API route](!docs!/learn/basics/api-routes)
- [How to Create a Middleware](!docs!/learn/advanced-development/api-routes/middlewares)
- [Learn more about the /auth route](../../../../commerce-modules/auth/authentication-route/page.mdx)

---

## Step 6: Add Product API Routes

In this section, you’ll add two API routes: one to retrieve the vendor’s products and one to create a product.

To create the API route that retrieves the vendor’s products, create the file `src/api/vendors/products/route.ts` with the following content:

export const retrieveProductHighlights = [
  ["16", "retrieveVendorAdmin", "Retrive the vendor admin to retrieve its vendor's ID."],
  ["23", "graph", "Retrieve the vendor's products using Query."]
]

```ts title="src/api/vendors/products/route.ts" highlights={retrieveProductHighlights}
import { AuthenticatedMedusaRequest, MedusaResponse } from "@medusajs/framework/http"
import { 
  ContainerRegistrationKeys,
} from "@medusajs/framework/utils"
import MarketplaceModuleService from "../../../modules/marketplace/service"
import { MARKETPLACE_MODULE } from "../../../modules/marketplace"

export const GET = async (
  req: AuthenticatedMedusaRequest,
  res: MedusaResponse
) => {
  const query = req.scope.resolve(ContainerRegistrationKeys.QUERY)
  const marketplaceModuleService: MarketplaceModuleService = 
    req.scope.resolve(MARKETPLACE_MODULE)

  const vendorAdmin = await marketplaceModuleService.retrieveVendorAdmin(
    req.auth_context.actor_id,
    {
      relations: ["vendor"],
    }
  )

  const { data: [vendor] } = await query.graph({
    entity: "vendor",
    fields: ["products.*"],
    filters: {
      id: [vendorAdmin.vendor.id],
    },
  })

  res.json({
    products: vendor.products,
  })
}
```

This adds a `GET` API route at `/vendors/products` that, using Query, retrieves the list of products of the vendor and returns them in the response.

To add the create product API route, add to the same file the following:

export const createProducts1Highlights = [
  ["15", "CreateProductWorkflowInputDTO", "Accept the same request body as Medusa's Create Product API route"],
  ["32", "retrieveVendorAdmin", "Retrive the vendor admin to retrieve its vendor's ID."],
]

```ts title="src/api/vendors/products/route.ts" highlights={createProducts1Highlights}
// other imports...
import { createProductsWorkflow } from "@medusajs/medusa/core-flows"
import { 
  CreateProductWorkflowInputDTO,
  IProductModuleService,
  ISalesChannelModuleService,
} from "@medusajs/framework/types"
import { 
  Modules, 
  Modules,
} from "@medusajs/framework/utils"

// GET method...

type RequestType = CreateProductWorkflowInputDTO

export const POST = async (
  req: AuthenticatedMedusaRequest<RequestType>,
  res: MedusaResponse
) => {
  const remoteLink = req.scope.resolve("remoteLink")
  const marketplaceModuleService: MarketplaceModuleService = 
    req.scope.resolve(MARKETPLACE_MODULE)
  const productModuleService: IProductModuleService = req.scope
    .resolve(Modules.PRODUCT)
  const salesChannelModuleService: ISalesChannelModuleService = req.scope
    .resolve(Modules.SALES_CHANNEL)
  // Retrieve default sales channel to make the product available in.
  // Alternatively, you can link sales channels to vendors and allow vendors
  // to manage sales channels
  const salesChannels = await salesChannelModuleService.listSalesChannels()
  const vendorAdmin = await marketplaceModuleService.retrieveVendorAdmin(
    req.auth_context.actor_id,
    {
      relations: ["vendor"],
    }
  )
  
  // TODO create and link product
}
```

This adds a `POST` API route at `/vendors/products`. It resolves the necessary modules' main services, and retrieves the sales channels and vendor admin.

In the place of the `TODO`, add the following:

export const createProducts2Highlights = [
  ["1", "createProductsWorkflow", "Use Medusa's workflow to create a product."],
  ["12", "create", "Create a link between the created product and the vendor."]
]

```ts title="src/api/vendors/products/route.ts" highlights={createProducts2Highlights}
const { result } = await createProductsWorkflow(req.scope)
  .run({
    input: {
      products: [{
        ...req.body,
        sales_channels: salesChannels,
      }],
    },
  })

// link product to vendor
await remoteLink.create({
  [MARKETPLACE_MODULE]: {
    vendor_id: vendorAdmin.vendor.id,
  },
  [Modules.PRODUCT]: {
    product_id: result[0].id,
  },
})

// retrieve product again
const product = await productModuleService.retrieveProduct(
  result[0].id
)

res.json({
  product,
})
```

This creates a product, links it to the vendor, and returns the product in the response.

<Note>

In the route handler, you add the product to the default sales channel. You can, instead, link sales channels with vendors similar to the steps explained in step 2.

</Note>

Finally, in `src/api/middlewares.ts`, apply a middleware on the create products route to validate the request body before executing the route handler:

```ts title="src/api/middlewares.ts"
import { 
  defineMiddlewares,
  authenticate,
} from "@medusajs/medusa"
import { 
  validateAndTransformBody,
} from "@medusajs/framework/utils"
import { 
  AdminCreateProduct,
} from "@medusajs/medusa/api/admin/products/validators"

export default defineMiddlewares({
  routes: [
    // ...
    {
      matcher: "/vendors/products",
      method: "POST",
      middlewares: [
        authenticate("vendor", ["session", "bearer"]),
        validateAndTransformBody(AdminCreateProduct),
      ],
    },
  ],
})
```

### Test it Out

To test out the new API routes:

1. Send a `POST` request to `/vendors/products` to create a product:

```bash
curl -X POST 'http://localhost:9000/vendors/products' \
-H 'Content-Type: application/json' \
-H 'Authorization: Bearer {token}' \
--data '{
    "title": "T-Shirt",
    "status": "published",
    "options": [
        {
            "title": "Color",
            "values": ["Blue"]
        }
    ],
    "variants": [
        {
            "title": "T-Shirt",
            "prices": [
                {
                    "currency_code": "eur",
                    "amount": 10
                }
            ],
            "manage_inventory": false,
            "options": {
                "Color": "Blue"
            }
        }
    ]
}'
```

2. Send a `GET` request to `/vendors/products` to retrieve the vendor’s products:

```bash
curl 'http://localhost:9000/vendors/products' \
-H 'Authorization: Bearer {token}'
```

### Further Reads

- [How to use Query](!docs!/learn/advanced-development/module-links/query)
- [How to use the Remote Link](!docs!/learn/advanced-development/module-links/remote-link)

---

## Step 7: Create Vendor Order Workflow

In this step, you’ll create a workflow that’s executed when the customer places an order. It has the following steps:

```mermaid
graph TD
  retrieveCartStep["Retrieve Cart (useRemoteQueryStep from Medusa)"] --> completeCartWorkflow["completeCartWorkflow (Medusa)"]
  completeCartWorkflow["completeCartWorkflow (Medusa)"] --> groupVendorItemsStep
  groupVendorItemsStep --> getOrderDetailWorkflow
  getOrderDetailWorkflow --> createVendorOrdersStep
  createVendorOrdersStep --> createRemoteLinkStep["Create Links (createRemoteLinkStep from Medusa)"]
```

1. Retrieve the cart using its ID. Medusa provides a `useRemoteQueryStep` in the `@medusajs/medusa/core-flows` package that you can use.
2. Create a parent order for the cart and its items. Medusa also has a `completeCartWorkflow` in the `@medusajs/medusa/core-flows` package that you can use as a step.
3. Group the cart items by their product’s associated vendor.
4. Retrieve the order's details using Medusa's `getOrderDetailWorkflow` exported by the `@medusajs/medusa/core-flows` package.
5. For each vendor, create a child order with the cart items of their products, and return the orders with the links to be created.
6. Create the links created by the previous step. Medusa provides a `createRemoteLinkStep` in the `@medusajs/medusa/core-flows` package that you can use.

You'll implement the third and fourth steps.

### groupVendorItemsStep

Create the third step in the file `src/workflows/marketplace/create-vendor-orders/steps/group-vendor-items.ts`:

```ts title="src/workflows/marketplace/create-vendor-orders/steps/group-vendor-items.ts"
import { 
  createStep,
  StepResponse,
} from "@medusajs/framework/workflows-sdk"
import { CartDTO, CartLineItemDTO } from "@medusajs/framework/types"
import { ContainerRegistrationKeys } from "@medusajs/framework/utils"

type StepInput = {
  cart: CartDTO
}

const groupVendorItemsStep = createStep(
  "group-vendor-items",
  async ({ cart }: StepInput, { container }) => {
    const query = container.resolve(ContainerRegistrationKeys.QUERY)

    const vendorsItems: Record<string, CartLineItemDTO[]> = {}

    await Promise.all(cart.items?.map(async (item) => {
      const { data: [product] } = await query.graph({
        entity: "product",
        fields: ["vendor.*"],
        filters: {
          id: [item.product_id],
        },
      })

      const vendorId = product.vendor?.id

      if (!vendorId) {
        return
      }
      vendorsItems[vendorId] = [
        ...(vendorsItems[vendorId] || []),
        item,
      ]
    }))

    return new StepResponse({
      vendorsItems,
    })
  }
)

export default groupVendorItemsStep
```

This step groups the items by the vendor associated with the product into an object and returns the object.

### createVendorOrdersStep

Next, create the fourth step in the file `src/workflows/marketplace/create-vendor-orders/steps/create-vendor-orders.ts`:

export const vendorOrder1Highlights = [
  ["42", "linkDefs", "An array of links to be created."],
  ["59", "created_orders", "Pass the created orders to the compensation function."]
]

```ts title="src/workflows/marketplace/create-vendor-orders/steps/create-vendor-orders.ts" highlights={vendorOrder1Highlights} collapsibleLines="1-19" expandMoreLabel="Show Imports"
import { 
  createStep,
  StepResponse,
} from "@medusajs/framework/workflows-sdk"
import { 
  CartLineItemDTO, 
  OrderDTO,
  LinkDefinition,
  InferTypeOf,
} from "@medusajs/framework/types"
import { Modules } from "@medusajs/framework/utils"
import { 
  createOrdersWorkflow,
  cancelOrderWorkflow,
} from "@medusajs/medusa/core-flows"
import MarketplaceModuleService from "../../../../modules/marketplace/service"
import { MARKETPLACE_MODULE } from "../../../../modules/marketplace"
import Vendor from "../../../../modules/marketplace/models/vendor"

export type VendorOrder = (OrderDTO & {
  vendor: InferTypeOf<typeof Vendor>
})

type StepInput = {
  parentOrder: OrderDTO
  vendorsItems: Record<string, CartLineItemDTO[]>
}

function prepareOrderData(
  items: CartLineItemDTO[], 
  parentOrder: OrderDTO
) {
  // TODO format order data
}

const createVendorOrdersStep = createStep(
  "create-vendor-orders",
  async (
    { vendorsItems, parentOrder }: StepInput, 
    { container, context }
  ) => {
    const linkDefs: LinkDefinition[] = []
    const createdOrders: VendorOrder[] = []
    const vendorIds = Object.keys(vendorsItems)
    
    const marketplaceModuleService =
      container.resolve<MarketplaceModuleService>(MARKETPLACE_MODULE)

    const vendors = await marketplaceModuleService.listVendors({
      id: vendorIds,
    })

    // TODO create child orders

    return new StepResponse({ 
      orders: createdOrders, 
      linkDefs,
    }, {
      created_orders: createdOrders,
    })
  },
  async ({ created_orders }, { container, context }) => {  
    // TODO add compensation function
  }
)

export default createVendorOrdersStep
```

This creates a step that receives the grouped vendor items and the parent order. For now, it initializes variables and retrieves vendors by their IDs.

The step returns the created orders and the links to be created. It also passes the created orders to the compensation function

Replace the `TODO` in the step with the following:

export const vendorOrder2Highlights = [
  ["1", "", "If the order has items for one vendor only, the parent order is linked to the vendor."],
  ["20", "created_orders", "Since the order isn't a child order, it's not passed to the compensation function for cancelation."]
]

```ts title="src/workflows/marketplace/create-vendor-orders/steps/create-vendor-orders.ts" highlights={vendorOrder2Highlights}
if (vendorIds.length === 1) {
  linkDefs.push({
    [MARKETPLACE_MODULE]: {
      vendor_id: vendors[0].id,
    },
    [Modules.ORDER]: {
      order_id: parentOrder.id,
    },
  })

  createdOrders.push({
    ...parentOrder,
    vendor: vendors[0],
  })
  
  return new StepResponse({
    orders:  createdOrders,
    linkDefs,
  }, {
    created_orders: [],
  })
}

// TODO create multiple child orders
```

In the above snippet, if there's only one vendor in the group, the parent order is added to the `linkDefs` array and it's returned in the response.

<Note title="Tip">

Since the parent order isn't a child order, it's not passed to the compensation function as it should only handle child orders.

</Note>

Next, replace the new `TODO` with the following snippet:

export const vendorOrder3Highlights = [
  ["3", "map", "Loop over the vendor IDs and create a child order with only their items."],
  ["11", "prepareOrderData", "Format the order data and pass it as the workflow's input."],
  ["18", "push", "Add a link between the vendor and the order to be created later."],
  ["30", "cancelOrderWorkflow", "Cancel all created workflows if an error occurs while creating any of them."]
]

```ts title="src/workflows/marketplace/create-vendor-orders/steps/create-vendor-orders.ts" highlights={vendorOrder3Highlights}
try {
  await Promise.all(
    vendorIds.map(async (vendorId) => {
      const items = vendorsItems[vendorId]
      const vendor = vendors.find((v) => v.id === vendorId)!

      const { result: childOrder } = await createOrdersWorkflow(
        container
      )
      .run({
        input: prepareOrderData(items, parentOrder),
        context,
      }) as unknown as { result: VendorOrder }

      childOrder.vendor = vendor
      createdOrders.push(childOrder)
      
      linkDefs.push({
        [MARKETPLACE_MODULE]: {
          vendor_id: vendor.id,
        },
        [Modules.ORDER]: {
          order_id: childOrder.id,
        },
      })
    })
  )
} catch (e) {
  await Promise.all(createdOrders.map((createdOrder) => {
    return cancelOrderWorkflow(container).run({
      input: {
        order_id: createdOrder.id,
      },
      context,
      container,
    })
  }))

  throw e
}
```

In this snippet, you create multiple child orders for each vendor and link the orders to the vendors.

If an error occurs, the created orders in the `createdOrders` array are canceled using Medusa's `cancelOrderWorkflow` from the `@medusajs/medusa/core-flows` package.

The order's data is formatted using the `prepareOrderData` function. Replace its definition with the following:

export const vendorOrder4Highlights = [
  ["8", "parent_order_id", "Set the ID of the parent order in the `metadata` property of the child order."],
]

```ts title="src/workflows/marketplace/create-vendor-orders/steps/create-vendor-orders.ts"
function prepareOrderData(
  items: CartLineItemDTO[], 
  parentOrder: OrderDTO
) {
  return  {
    items,
    metadata: {
      parent_order_id: parentOrder.id,
    },
    // use info from parent
    region_id: parentOrder.region_id,
    customer_id: parentOrder.customer_id,
    sales_channel_id: parentOrder.sales_channel_id,
    email: parentOrder.email,
    currency_code: parentOrder.currency_code,
    shipping_address_id: parentOrder.shipping_address?.id,
    billing_address_id: parentOrder.billing_address?.id,
    // A better solution would be to have shipping methods for each
    // item/vendor. This requires changes in the storefront to commodate that
    // and passing the item/vendor ID in the `data` property, for example.
    // For simplicity here we just use the same shipping method.
    shipping_methods: parentOrder.shipping_methods.map((shippingMethod) => ({
      name: shippingMethod.name,
      amount: shippingMethod.amount,
      shipping_option_id: shippingMethod.shipping_option_id,
      data: shippingMethod.data,
      tax_lines: shippingMethod.tax_lines.map((taxLine) => ({
        code: taxLine.code,
        rate: taxLine.rate,
        provider_id: taxLine.provider_id,
        tax_rate_id: taxLine.tax_rate_id,
        description: taxLine.description,
      })),
      adjustments: shippingMethod.adjustments.map((adjustment) => ({
        code: adjustment.code,
        amount: adjustment.amount,
        description: adjustment.description,
        promotion_id: adjustment.promotion_id,
        provider_id: adjustment.provider_id,
      })),
    })),
  }
}
```

This formats the order's data using the items and parent order's details.

<Note>

When creating the child orders, the shipping method of the parent is used as-is for simplicity. A better practice would be to allow the customer to choose different shipping methods for each vendor’s items and then store those details in the `data` property of the shipping method.

</Note>

Finally, replace the `TODO` in the compensation function with the following:

```ts title="src/workflows/marketplace/create-vendor-orders/steps/create-vendor-orders.ts"
await Promise.all(created_orders.map((createdOrder) => {
  return cancelOrderWorkflow(container).run({
    input: {
      order_id: createdOrder.id,
    },
    context,
    container,
  })
}))
```

The compensation function cancels all child orders received from the step. It uses the `cancelOrderWorkflow` that Medusa provides in the `@medusajs/medusa/core-flows` package.

### Create Workflow

Finally, create the workflow at the file `src/workflows/marketplace/create-vendor-orders/index.ts`:

export const createVendorOrdersWorkflowHighlights = [
  ["21", "useRemoteQueryStep", "Retrieve the cart's details."],
  ["29", "completeCartWorkflow", "Create the parent order from the cart."],
  ["35", "groupVendorItemsStep", "Group the items by their vendor."],
  ["42", "createVendorOrdersStep", "Create child orders for each vendor"],
  ["47", "createRemoteLinkStep", "Create the links returned by the previous step."]
]

```ts title="src/workflows/marketplace/create-vendor-orders/index.ts" collapsibleLines="1-13" expandMoreLabel="Show Imports"
import { 
  createWorkflow,
  WorkflowResponse,
} from "@medusajs/framework/workflows-sdk"
import { 
  useRemoteQueryStep,
  createRemoteLinkStep,
  completeCartWorkflow,
  getOrderDetailWorkflow
} from "@medusajs/medusa/core-flows"
import { CartDTO } from "@medusajs/framework/types"
import groupVendorItemsStep from "./steps/group-vendor-items"
import createVendorOrdersStep from "./steps/create-vendor-orders"

type WorkflowInput = {
  cart_id: string
}

const createVendorOrdersWorkflow = createWorkflow(
  "create-vendor-order",
  (input: WorkflowInput) => {
    const cart = useRemoteQueryStep({
      entry_point: "cart",
      fields: ["items.*"],
      variables: { id: input.cart_id },
      list: false,
      throw_if_key_not_found: true,
    }) as CartDTO

    const { id: orderId } = completeCartWorkflow.runAsStep({
      input: {
        id: cart.id
      }
    })

    const { vendorsItems } = groupVendorItemsStep({
      cart,
    })

    const order = getOrderDetailWorkflow.runAsStep({
      input: {
        order_id: orderId,
        fields: [
          "region_id",
          "customer_id",
          "sales_channel_id",
          "email",
          "currency_code",
          "shipping_address.*",
          "billing_address.*",
          "shipping_methods.*",
        ]
      }
    })

    const { 
      orders: vendorOrders, 
      linkDefs,
    } = createVendorOrdersStep({
      parentOrder: order,
      vendorsItems,
    })

    createRemoteLinkStep(linkDefs)

    return new WorkflowResponse({
      parent_order: order,
      vendor_orders: vendorOrders,
    })
  }
)

export default createVendorOrdersWorkflow
```

In the workflow, you run the following steps:

1. `useRemoteQueryStep` to retrieve the cart's details.
2. `completeCartWorkflow` to complete the cart and create a parent order.
3. `groupVendorItemsStep` to group the order's items by their vendor.
4. `createVendorOrdersStep` to create child orders for each vendor's items.
5. `createRemoteLinkStep` to create the links returned by the previous step.

You return the parent and vendor orders.

### Create API Route Executing the Workflow

You’ll now create the API route that executes the workflow.

Create the file `src/api/store/carts/[id]/complete/route.ts` with the following content:

```ts title="src/api/store/carts/[id]/complete/route.ts"
import { 
  AuthenticatedMedusaRequest, 
  MedusaResponse,
} from "@medusajs/framework/http"
import createVendorOrdersWorkflow from "../../../../../workflows/marketplace/create-vendor-orders"

export const POST = async (
  req: AuthenticatedMedusaRequest,
  res: MedusaResponse
) => {
  const cartId = req.params.id

  const { result } = await createVendorOrdersWorkflow(req.scope)
    .run({
      input: {
        cart_id: cartId,
      },
    })

  res.json({
    type: "order",
    order: result.parent_order,
  })
}
```

This API route replaces the [existing API route in the Medusa application](!api!/store#carts_postcartsidcomplete) used to complete the cart and place an order. It executes the workflow and returns the parent order in the response.

### Test it Out

To test this out, it’s recommended to install the [Next.js Starter storefront](../../../../nextjs-starter/page.mdx). Then, add products to the cart and place an order. You can also try placing an order with products from different vendors.

---

## Step 8: Retrieve Vendor Orders API Route

In this step, you’ll create an API route that retrieves a vendor’s orders.

Create the file `src/api/vendors/orders/route.ts` with the following content:

export const getOrderHighlights = [
  ["15", "retrieveVendorAdmin", "Retrive the vendor admin to retrieve its vendor's ID."],
  ["22", "graph", "Retrieve the orders of the vendor."],
  ["32", "getOrdersListWorkflow", "Use Medusa's workflow to retrieve the list of orders."],
]

```ts title="src/api/vendors/orders/route.ts" highlights={getOrderHighlights} collapsibleLines="1-6" expandMoreLabel="Show Imports"
import { AuthenticatedMedusaRequest, MedusaResponse } from "@medusajs/framework/http"
import { ContainerRegistrationKeys } from "@medusajs/framework/utils"
import { getOrdersListWorkflow } from "@medusajs/medusa/core-flows"
import MarketplaceModuleService from "../../../modules/marketplace/service"
import { MARKETPLACE_MODULE } from "../../../modules/marketplace"

export const GET = async (
  req: AuthenticatedMedusaRequest,
  res: MedusaResponse
) => {
  const query = req.scope.resolve(ContainerRegistrationKeys.QUERY)
  const marketplaceModuleService: MarketplaceModuleService = 
    req.scope.resolve(MARKETPLACE_MODULE)

  const vendorAdmin = await marketplaceModuleService.retrieveVendorAdmin(
    req.auth_context.actor_id,
    {
      relations: ["vendor"],
    }
  )

  const { data: [vendor] } = await query.graph({
    entity: "vendor",
    fields: ["orders.*"],
    filters: {
      id: [vendorAdmin.vendor.id],
    },
  })

  const { result: orders } = await getOrdersListWorkflow(req.scope)
    .run({
      input: {
        fields: [
          "metadata",
          "total",
          "subtotal",
          "shipping_total",
          "tax_total",
          "items.*",
          "items.tax_lines",
          "items.adjustments",
          "items.variant",
          "items.variant.product",
          "items.detail",
          "shipping_methods",
          "payment_collections",
          "fulfillments",
        ],
        variables: {
          filters: {
            id: vendor.orders.map((order) => order.id),
          },
        },
      },
    })

  res.json({
    orders,
  })
}
```

This adds a `GET` API route at `/vendors/orders` that returns a vendor’s list of orders.

### Test it Out

To test it out, send a `GET` request to `/vendors/orders` :

```bash
curl 'http://localhost:9000/vendors/orders' \
-H 'Authorization: Bearer {token}'
```

Make sure to replace the `{token}` with the vendor admin’s token.

You’ll receive in the response the orders of the vendor created in the previous step.

---

## Next Steps

The next steps of this example depend on your use case. This section provides some insight into implementing them.

### Use Existing Features

You can use [Medusa’s admin API routes for orders](!api!/admin) to allow vendors to manage their orders. This requires you to add the following middleware in `src/api/middlewares.ts`:

```ts title="src/api/middlewares.ts"
export default defineMiddlewares({
  routes: [
	  // ...
    {
      matcher: "/admin/orders/*",
      method: "POST",
      middlewares: [
        authenticate("vendor", ["session", "bearer"]),
      ],
    },
  ],
})
```

You can also re-create or override any of the existing API routes, similar to what you did with the complete cart API route.

### Link Other Data Models to Vendors

Similar to linking an order and a product to a vendor, you can link other data models to vendors as well.

For example, you can link sales channels to vendors or other settings.

<Note>

[Learn more about module links](!docs!/learn/advanced-development/module-links).

</Note>

### Storefront Development

Medusa provides a Next.js Starter storefront that you can customize to your use case.

You can also create a custom storefront. Check out the [Storefront Development](../../../../storefront-development/page.mdx) section to learn how to create a storefront.

### Admin Development

The Medusa Admin is extendable, allowing you to add widgets to existing pages or create new pages. Learn more about it in [this documentation](!docs!/learn/advanced-development/admin).

If your use case requires bigger customizations to the admin, such as showing different products and orders based on the logged-in vendor, use the [admin API routes](!api!/admin) to build a custom admin.
