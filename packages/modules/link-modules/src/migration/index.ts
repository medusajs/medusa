import {
  ILinkMigrationsPlanner,
  LinkMigrationsPlannerAction,
  ModuleJoinerConfig,
  ModuleServiceInitializeOptions,
  PlannerActionLinkDescriptor,
} from "@medusajs/types"

import { generateEntity } from "../utils"
import { EntitySchema, MikroORM } from "@mikro-orm/core"
import { DatabaseSchema, PostgreSqlDriver } from "@mikro-orm/postgresql"
import {
  DALUtils,
  promiseAll,
  ModulesSdkUtils,
  arrayDifference,
} from "@medusajs/utils"

/**
 * The migrations execution planner creates a plan of SQL queries
 * to be executed to keep link modules database state in sync
 * with the links defined inside the user application.
 */
export class MigrationsExecutionPlanner implements ILinkMigrationsPlanner {
  /**
   * Database options for the module service
   */
  #dbConfig: ReturnType<typeof ModulesSdkUtils.loadDatabaseConfig>

  /**
   * The set of commands that are unsafe to execute automatically when
   * performing "alter table"
   */
  #unsafeSQLCommands = ["alter column", "drop column"]

  /**
   * On-the-fly computed set of entities for the user provided joinerConfig and the link it is coming from
   */
  #linksEntities: {
    linkDescriptor: PlannerActionLinkDescriptor
    entity: EntitySchema
  }[]

  /**
   * The table that keeps a track of tables generated by the link
   * module.
   */
  protected tableName = "link_module_migrations"

  constructor(
    joinerConfig: ModuleJoinerConfig[],
    options?: ModuleServiceInitializeOptions
  ) {
    this.#dbConfig = ModulesSdkUtils.loadDatabaseConfig("link_modules", options)
    this.#linksEntities = joinerConfig
      .map((config) => {
        if (config.isReadOnlyLink) {
          return
        }

        const [primary, foreign] = config.relationships ?? []
        const linkDescriptor: PlannerActionLinkDescriptor = {
          fromModule: primary.serviceName,
          toModule: foreign.serviceName,
          fromModel: primary.alias,
          toModel: foreign.alias,
        }

        return {
          entity: generateEntity(config, primary, foreign),
          linkDescriptor,
        }
      })
      .filter((item) => !!item)
  }

  /**
   * Initializes the ORM using the normalized dbConfig and set
   * of provided entities
   */
  protected async createORM(entities: EntitySchema[] = []) {
    return await DALUtils.mikroOrmCreateConnection(this.#dbConfig, entities, "")
  }

  /**
   * Ensure the table to track link modules migrations
   * exists.
   *
   * @param orm MikroORM
   */
  protected async ensureMigrationsTable(
    orm: MikroORM<PostgreSqlDriver>
  ): Promise<void> {
    await orm.em.getDriver().getConnection().execute(`
      CREATE TABLE IF NOT EXISTS "${this.tableName}" (
        id SERIAL PRIMARY KEY,
        table_name VARCHAR(255) NOT NULL,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      )
    `)
  }

  /**
   * Insert or delete tuple from the migrations table
   *
   * @param orm
   * @param tableName
   * @param action
   * @protected
   */
  protected async trackLinkTable(
    orm: MikroORM<PostgreSqlDriver>,
    tableName: string
  ) {
    await orm.em.getDriver().getConnection().execute(`
      INSERT INTO "${this.tableName}" (table_name) VALUES ('${tableName}')
    `)
  }

  /**
   * Drops the link table and untracks it from the "link_modules_migrations"
   * table.
   */
  protected async dropLinkTable(
    orm: MikroORM<PostgreSqlDriver>,
    tableName: string
  ) {
    await orm.em.getDriver().getConnection().execute(`
      DROP TABLE IF EXISTS "${tableName}"
    `)
    await orm.em.getDriver().getConnection().execute(`
      DELETE FROM "${this.tableName}" WHERE table_name = '${tableName}')
    `)
  }

  /**
   * Returns an array of table names that have been tracked during
   * the last run. In short, these tables were created by the
   * link modules migrations runner.
   *
   * @param orm MikroORM
   */
  protected async getTrackedLinksTables(
    orm: MikroORM<PostgreSqlDriver>
  ): Promise<string[]> {
    const results = await orm.em.getDriver().getConnection().execute<
      {
        table_name: string
      }[]
    >(`
      SELECT table_name from "${this.tableName}"
    `)

    return results.map((tuple) => tuple.table_name)
  }

  /**
   * Returns the migration plan for a specific link entity.
   */
  protected async getEntityMigrationPlan(
    linkDescriptor: PlannerActionLinkDescriptor,
    entity: EntitySchema,
    trackedLinksTables: string[]
  ): Promise<LinkMigrationsPlannerAction> {
    const tableName = entity.meta.collection
    const orm = await this.createORM([entity])

    const generator = orm.getSchemaGenerator()
    const platform = orm.em.getPlatform()
    const connection = orm.em.getConnection()
    const schemaName = this.#dbConfig.schema || "public"

    /**
     * If the table name for the entity has not been
     * managed by us earlier, then we should create
     * it.
     */
    if (!trackedLinksTables.includes(tableName)) {
      return {
        action: "create",
        linkDescriptor,
        tableName,
        sql: await generator.getCreateSchemaSQL(),
      }
    }

    /**
     * Pre-fetching information schema from the database and using that
     * as the way to compute the update diff.
     *
     * @note
     * The "loadInformationSchema" mutates the "dbSchema" argument provided
     * to it as the first argument.
     */
    const dbSchema = new DatabaseSchema(platform, schemaName)
    await platform
      .getSchemaHelper?.()
      ?.loadInformationSchema(dbSchema, connection, [
        {
          table_name: tableName,
          schema_name: schemaName,
        },
      ])

    const updateSQL = await generator.getUpdateSchemaSQL({
      fromSchema: dbSchema,
    })

    /**
     * Entity is upto-date and hence we do not have to perform
     * any updates on it.
     */
    if (!updateSQL.length) {
      return {
        action: "noop",
        linkDescriptor,
        tableName,
      }
    }

    const usesUnsafeCommands = this.#unsafeSQLCommands.some((fragment) => {
      return updateSQL.match(new RegExp(`${fragment}`, "ig"))
    })

    return {
      action: usesUnsafeCommands ? "notify" : "update",
      linkDescriptor,
      tableName,
      sql: updateSQL,
    }
  }

  /**
   * Creates a plan to executed in order to keep the database state in
   * sync with the user-defined links.
   *
   * This method only creates a plan and does not change the database
   * state. You must call the "executePlan" method for that.
   */
  async createPlan() {
    const orm = await this.createORM()
    await this.ensureMigrationsTable(orm)

    const executionActions: LinkMigrationsPlannerAction[] = []
    const trackedTables = await this.getTrackedLinksTables(orm)

    /**
     * Looping through the new set of entities and generating
     * execution plan for them
     */
    for (let { entity, linkDescriptor } of this.#linksEntities) {
      executionActions.push(
        await this.getEntityMigrationPlan(linkDescriptor, entity, trackedTables)
      )
    }

    const linksTableNames = this.#linksEntities.map(
      ({ entity }) => entity.meta.collection
    )

    /**
     * Finding the tables to be removed
     */
    const tablesToRemove = arrayDifference(trackedTables, linksTableNames)
    tablesToRemove.forEach((tableToRemove) => {
      executionActions.push({
        action: "delete",
        tableName: tableToRemove,
      })
    })

    return executionActions
  }

  /**
   * Executes the actionsPlan actions
   *
   * @param actionPlan
   */
  async executePlan(actionPlan: LinkMigrationsPlannerAction[]): Promise<void> {
    const orm = await this.createORM()

    await promiseAll(
      actionPlan.map(async (action) => {
        switch (action.action) {
          case "noop":
          case "notify":
            return
          case "delete":
            await this.dropLinkTable(orm, action.tableName)
            return
          case "create":
            await orm.em.getDriver().getConnection().execute(action.sql)
            await this.trackLinkTable(orm, action.tableName)
            return
          case "update":
            await orm.em.getDriver().getConnection().execute(action.sql)
        }
      })
    )
  }
}
