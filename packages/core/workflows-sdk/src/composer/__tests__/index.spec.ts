import {
  IDistributedSchedulerStorage,
  SchedulerOptions,
  WorkflowManager,
  WorkflowScheduler,
} from "@medusajs/orchestration"
import { IEventBusModuleService } from "@medusajs/types"
import {
  composeMessage,
  createMedusaContainer,
  Modules,
  promiseAll,
} from "@medusajs/utils"
import { asValue } from "awilix"
import {
  createHook,
  createStep,
  MedusaWorkflow,
  parallelize,
  StepResponse,
  transform,
  WorkflowResponse,
} from "../.."
import { createWorkflow } from "../composer"

jest.setTimeout(30000)

class MockSchedulerStorage implements IDistributedSchedulerStorage {
  schedule(
    jobDefinition: string | { jobId: string },
    schedulerOptions: SchedulerOptions
  ): Promise<void> {
    return Promise.resolve()
  }
  remove(jobId: string): Promise<void> {
    return Promise.resolve()
  }
  removeAll(): Promise<void> {
    return Promise.resolve()
  }
}

WorkflowScheduler.setStorage(new MockSchedulerStorage())

const afterEach_ = () => {
  jest.clearAllMocks()
  MedusaWorkflow.workflows = {}
  WorkflowManager.unregisterAll()
}

describe("Workflow composer", function () {
  afterEach(afterEach_)

  describe("Using steps returning plain values", function () {
    afterEach(afterEach_)

    it("should compose a workflow and pass down the event group id provided as part of the context", async () => {
      let context
      const mockStep1Fn = jest
        .fn()
        .mockImplementation((input, { context: stepContext }) => {
          context = stepContext
        })

      const step1 = createStep("step1", mockStep1Fn)

      const workflow = createWorkflow("workflow1", function (input) {
        step1(input)
      })

      await workflow.run({
        context: {
          eventGroupId: "event-group-id",
        },
      })

      expect(mockStep1Fn).toHaveBeenCalledTimes(1)
      expect(mockStep1Fn.mock.calls[0]).toHaveLength(2)
      expect(context.eventGroupId).toEqual("event-group-id")
    })

    it("should compose a workflow and pass down the autogenerated event group id if not provided as part of the context", async () => {
      let context
      const mockStep1Fn = jest
        .fn()
        .mockImplementation((input, { context: stepContext }) => {
          context = stepContext
        })

      const step1 = createStep("step1", mockStep1Fn)

      const workflow = createWorkflow("workflow1", function (input) {
        step1(input)
      })

      await workflow.run({})

      expect(mockStep1Fn).toHaveBeenCalledTimes(1)
      expect(mockStep1Fn.mock.calls[0]).toHaveLength(2)
      expect(context.eventGroupId).toBeTruthy()
    })

    it("should compose a new workflow composed retryable steps", async () => {
      const maxRetries = 1

      const mockStep1Fn = jest.fn().mockImplementation((input, context) => {
        const attempt = context.metadata.attempt || 0
        if (attempt <= maxRetries) {
          throw new Error("test error")
        }

        return { inputs: [input], obj: "return from 1" }
      })

      const step1 = createStep({ name: "step1", maxRetries }, mockStep1Fn)

      const workflow = createWorkflow("workflow1", function (input) {
        return new WorkflowResponse(step1(input))
      })

      const workflowInput = { test: "payload1" }
      const { result: workflowResult } = await workflow.run({
        input: workflowInput,
      })

      expect(mockStep1Fn).toHaveBeenCalledTimes(2)
      expect(mockStep1Fn.mock.calls[0]).toHaveLength(2)
      expect(mockStep1Fn.mock.calls[0][0]).toEqual(workflowInput)
      expect(mockStep1Fn.mock.calls[1][0]).toEqual(workflowInput)

      expect(workflowResult).toEqual({
        inputs: [{ test: "payload1" }],
        obj: "return from 1",
      })
    })

    it("should compose a new workflow and execute it", async () => {
      const mockStep1Fn = jest.fn().mockImplementation((input) => {
        return { inputs: [input], obj: "return from 1" }
      })
      const mockStep2Fn = jest.fn().mockImplementation((...inputs) => {
        inputs.pop()
        return {
          inputs,
          obj: "return from 2",
        }
      })
      const mockStep3Fn = jest.fn().mockImplementation((...inputs) => {
        inputs.pop()
        return {
          inputs,
          obj: "return from 3",
        }
      })

      const step1 = createStep("step1", mockStep1Fn)
      const step2 = createStep("step2", mockStep2Fn)
      const step3 = createStep("step3", mockStep3Fn)

      const workflow = createWorkflow("workflow1", function (input) {
        const returnStep1 = step1(input)
        const ret2 = step2(returnStep1)
        return new WorkflowResponse(step3({ one: returnStep1, two: ret2 }))
      })

      const workflowInput = { test: "payload1" }
      const { result: workflowResult } = await workflow.run({
        input: workflowInput,
      })

      expect(mockStep1Fn).toHaveBeenCalledTimes(1)
      expect(mockStep1Fn.mock.calls[0]).toHaveLength(2)
      expect(mockStep1Fn.mock.calls[0][0]).toEqual(workflowInput)

      expect(mockStep2Fn).toHaveBeenCalledTimes(1)
      expect(mockStep2Fn.mock.calls[0]).toHaveLength(2)
      expect(mockStep2Fn.mock.calls[0][0]).toEqual({
        inputs: [workflowInput],
        obj: "return from 1",
      })

      expect(mockStep3Fn).toHaveBeenCalledTimes(1)
      expect(mockStep3Fn.mock.calls[0]).toHaveLength(2)
      expect(mockStep3Fn.mock.calls[0][0]).toEqual({
        one: {
          inputs: [workflowInput],
          obj: "return from 1",
        },
        two: {
          inputs: [
            {
              inputs: [workflowInput],
              obj: "return from 1",
            },
          ],
          obj: "return from 2",
        },
      })

      expect(workflowResult).toEqual({
        inputs: [
          {
            one: {
              inputs: [workflowInput],
              obj: "return from 1",
            },
            two: {
              inputs: [
                {
                  inputs: [workflowInput],
                  obj: "return from 1",
                },
              ],
              obj: "return from 2",
            },
          },
        ],
        obj: "return from 3",
      })
    })

    it("should compose two new workflows sequentially and execute them sequentially", async () => {
      const mockStep1Fn = jest.fn().mockImplementation((input, context) => {
        return { inputs: [input], obj: "return from 1" }
      })
      const mockStep2Fn = jest.fn().mockImplementation((...inputs) => {
        inputs.pop()
        return {
          inputs,
          obj: "return from 2",
        }
      })
      const mockStep3Fn = jest.fn().mockImplementation((...inputs) => {
        inputs.pop()
        return {
          inputs,
          obj: "return from 3",
        }
      })

      const step1 = createStep("step1", mockStep1Fn)
      const step2 = createStep("step2", mockStep2Fn)
      const step3 = createStep("step3", mockStep3Fn)

      const workflow = createWorkflow("workflow1", function (input) {
        const returnStep1 = step1(input)
        const ret2 = step2(returnStep1)
        return new WorkflowResponse(step3({ one: returnStep1, two: ret2 }))
      })

      const workflow2 = createWorkflow("workflow2", function (input) {
        const returnStep1 = step1(input)
        const ret2 = step2(returnStep1)
        return new WorkflowResponse(step3({ one: returnStep1, two: ret2 }))
      })

      const workflowInput = { test: "payload1" }
      const { result: workflowResult } = await workflow.run({
        input: workflowInput,
      })

      const workflow2Input = { test: "payload2" }
      const { result: workflow2Result } = await workflow2.run({
        input: workflow2Input,
      })

      expect(mockStep1Fn).toHaveBeenCalledTimes(2)
      expect(mockStep1Fn.mock.calls[0]).toHaveLength(2)
      expect(mockStep1Fn.mock.calls[0][0]).toEqual(workflowInput)
      expect(mockStep1Fn.mock.calls[1][0]).toEqual(workflow2Input)

      expect(mockStep2Fn).toHaveBeenCalledTimes(2)
      expect(mockStep2Fn.mock.calls[0]).toHaveLength(2)
      expect(mockStep2Fn.mock.calls[0][0]).toEqual({
        inputs: [{ test: "payload1" }],
        obj: "return from 1",
      })
      expect(mockStep2Fn.mock.calls[1][0]).toEqual({
        inputs: [{ test: "payload2" }],
        obj: "return from 1",
      })

      expect(mockStep3Fn).toHaveBeenCalledTimes(2)
      expect(mockStep3Fn.mock.calls[0]).toHaveLength(2)
      expect(mockStep3Fn.mock.calls[0][0]).toEqual({
        one: { inputs: [{ test: "payload1" }], obj: "return from 1" },
        two: {
          inputs: [{ inputs: [{ test: "payload1" }], obj: "return from 1" }],
          obj: "return from 2",
        },
      })
      expect(mockStep3Fn.mock.calls[1][0]).toEqual({
        one: { inputs: [{ test: "payload2" }], obj: "return from 1" },
        two: {
          inputs: [{ inputs: [{ test: "payload2" }], obj: "return from 1" }],
          obj: "return from 2",
        },
      })

      expect(workflowResult).toEqual({
        inputs: [
          {
            one: { inputs: [{ test: "payload1" }], obj: "return from 1" },
            two: {
              inputs: [
                { inputs: [{ test: "payload1" }], obj: "return from 1" },
              ],
              obj: "return from 2",
            },
          },
        ],
        obj: "return from 3",
      })
      expect(workflow2Result).toEqual({
        inputs: [
          {
            one: { inputs: [{ test: "payload2" }], obj: "return from 1" },
            two: {
              inputs: [
                { inputs: [{ test: "payload2" }], obj: "return from 1" },
              ],
              obj: "return from 2",
            },
          },
        ],
        obj: "return from 3",
      })
    })

    it("should compose two new workflows concurrently and execute them sequentially", async () => {
      const mockStep1Fn = jest.fn().mockImplementation((input, context) => {
        return { inputs: [input], obj: "return from 1" }
      })
      const mockStep2Fn = jest.fn().mockImplementation((...inputs) => {
        inputs.pop()
        return {
          inputs,
          obj: "return from 2",
        }
      })
      const mockStep3Fn = jest.fn().mockImplementation((...inputs) => {
        inputs.pop()
        return {
          inputs,
          obj: "return from 3",
        }
      })

      const step1 = createStep("step1", mockStep1Fn)
      const step2 = createStep("step2", mockStep2Fn)
      const step3 = createStep("step3", mockStep3Fn)

      const [workflow, workflow2] = await promiseAll([
        createWorkflow("workflow1", function (input) {
          const returnStep1 = step1(input)
          const ret2 = step2(returnStep1)
          return new WorkflowResponse(step3({ one: returnStep1, two: ret2 }))
        }),

        createWorkflow("workflow2", function (input) {
          const returnStep1 = step1(input)
          const ret2 = step2(returnStep1)
          return new WorkflowResponse(step3({ one: returnStep1, two: ret2 }))
        }),
      ])

      const workflowInput = { test: "payload1" }
      const { result: workflowResult } = await workflow.run({
        input: workflowInput,
      })

      const workflow2Input = { test: "payload2" }
      const { result: workflow2Result } = await workflow2.run({
        input: workflow2Input,
      })

      expect(mockStep1Fn).toHaveBeenCalledTimes(2)
      expect(mockStep1Fn.mock.calls[0]).toHaveLength(2)
      expect(mockStep1Fn.mock.calls[0][0]).toEqual(workflowInput)
      expect(mockStep1Fn.mock.calls[1][0]).toEqual(workflow2Input)

      expect(mockStep2Fn).toHaveBeenCalledTimes(2)
      expect(mockStep2Fn.mock.calls[0]).toHaveLength(2)
      expect(mockStep2Fn.mock.calls[0][0]).toEqual({
        inputs: [workflowInput],
        obj: "return from 1",
      })
      expect(mockStep2Fn.mock.calls[1][0]).toEqual({
        inputs: [workflow2Input],
        obj: "return from 1",
      })

      expect(mockStep3Fn).toHaveBeenCalledTimes(2)
      expect(mockStep3Fn.mock.calls[0]).toHaveLength(2)
      expect(mockStep3Fn.mock.calls[0][0]).toEqual({
        one: { inputs: [{ test: "payload1" }], obj: "return from 1" },
        two: {
          inputs: [{ inputs: [{ test: "payload1" }], obj: "return from 1" }],
          obj: "return from 2",
        },
      })
      expect(mockStep3Fn.mock.calls[1][0]).toEqual({
        one: { inputs: [{ test: "payload2" }], obj: "return from 1" },
        two: {
          inputs: [{ inputs: [{ test: "payload2" }], obj: "return from 1" }],
          obj: "return from 2",
        },
      })

      expect(workflowResult).toEqual({
        inputs: [
          {
            one: { inputs: [{ test: "payload1" }], obj: "return from 1" },
            two: {
              inputs: [
                { inputs: [{ test: "payload1" }], obj: "return from 1" },
              ],
              obj: "return from 2",
            },
          },
        ],
        obj: "return from 3",
      })
      expect(workflow2Result).toEqual({
        inputs: [
          {
            one: { inputs: [{ test: "payload2" }], obj: "return from 1" },
            two: {
              inputs: [
                { inputs: [{ test: "payload2" }], obj: "return from 1" },
              ],
              obj: "return from 2",
            },
          },
        ],
        obj: "return from 3",
      })
    })

    it("should compose two new workflows concurrently and execute them concurrently", async () => {
      const mockStep1Fn = jest.fn().mockImplementation((input, context) => {
        return { inputs: [input], obj: "return from 1" }
      })
      const mockStep2Fn = jest.fn().mockImplementation((...inputs) => {
        inputs.pop()
        return {
          inputs,
          obj: "return from 2",
        }
      })
      const mockStep3Fn = jest.fn().mockImplementation((...inputs) => {
        inputs.pop()
        return {
          inputs,
          obj: "return from 3",
        }
      })

      const step1 = createStep("step1", mockStep1Fn)
      const step2 = createStep("step2", mockStep2Fn)
      const step3 = createStep("step3", mockStep3Fn)

      const [workflow, workflow2] = await promiseAll([
        createWorkflow("workflow1", function (input) {
          const returnStep1 = step1(input)
          const ret2 = step2(returnStep1)
          return new WorkflowResponse(step3({ one: returnStep1, two: ret2 }))
        }),

        createWorkflow("workflow2", function (input) {
          const returnStep1 = step1(input)
          const ret2 = step2(returnStep1)
          return new WorkflowResponse(step3({ one: returnStep1, two: ret2 }))
        }),
      ])

      const workflowInput = { test: "payload1" }
      const workflow2Input = { test: "payload2" }

      const [{ result: workflowResult }, { result: workflow2Result }] =
        await promiseAll([
          workflow.run({
            input: workflowInput,
          }),
          workflow2.run({
            input: workflow2Input,
          }),
        ])

      expect(mockStep1Fn).toHaveBeenCalledTimes(2)
      expect(mockStep1Fn.mock.calls[0]).toHaveLength(2)
      expect(mockStep1Fn.mock.calls[0][0]).toEqual(workflowInput)
      expect(mockStep1Fn.mock.calls[1][0]).toEqual(workflow2Input)
      expect(mockStep1Fn.mock.calls[1]).toHaveLength(2)

      expect(mockStep2Fn).toHaveBeenCalledTimes(2)
      expect(mockStep2Fn.mock.calls[0]).toHaveLength(2)
      expect(mockStep2Fn.mock.calls[0][0]).toEqual({
        inputs: [workflowInput],
        obj: "return from 1",
      })
      expect(mockStep2Fn.mock.calls[1][0]).toEqual({
        inputs: [workflow2Input],
        obj: "return from 1",
      })

      expect(mockStep3Fn).toHaveBeenCalledTimes(2)
      expect(mockStep3Fn.mock.calls[0]).toHaveLength(2)
      expect(mockStep3Fn.mock.calls[0][0]).toEqual({
        one: { inputs: [{ test: "payload1" }], obj: "return from 1" },
        two: {
          inputs: [{ inputs: [{ test: "payload1" }], obj: "return from 1" }],
          obj: "return from 2",
        },
      })
      expect(mockStep3Fn.mock.calls[1][0]).toEqual({
        one: { inputs: [{ test: "payload2" }], obj: "return from 1" },
        two: {
          inputs: [{ inputs: [{ test: "payload2" }], obj: "return from 1" }],
          obj: "return from 2",
        },
      })

      expect(workflowResult).toEqual({
        inputs: [
          {
            one: { inputs: [{ test: "payload1" }], obj: "return from 1" },
            two: {
              inputs: [
                { inputs: [{ test: "payload1" }], obj: "return from 1" },
              ],
              obj: "return from 2",
            },
          },
        ],
        obj: "return from 3",
      })
      expect(workflow2Result).toEqual({
        inputs: [
          {
            one: { inputs: [{ test: "payload2" }], obj: "return from 1" },
            two: {
              inputs: [
                { inputs: [{ test: "payload2" }], obj: "return from 1" },
              ],
              obj: "return from 2",
            },
          },
        ],
        obj: "return from 3",
      })
    })

    it("should compose a new workflow and execute it multiple times concurrently", async () => {
      const mockStep1Fn = jest
        .fn()
        .mockImplementation(function (input, context) {
          return { inputs: [input], obj: "return from 1" }
        })
      const mockStep2Fn = jest.fn().mockImplementation(function (...inputs) {
        inputs.pop()
        return {
          inputs,
          obj: "return from 2",
        }
      })
      const mockStep3Fn = jest.fn().mockImplementation(function (...inputs) {
        inputs.pop()
        return {
          inputs,
          obj: "return from 3",
        }
      })

      const step1 = createStep("step1", mockStep1Fn)
      const step2 = createStep("step2", mockStep2Fn)
      const step3 = createStep("step3", mockStep3Fn)

      const workflow = createWorkflow("workflow1", function (input) {
        const returnStep1 = step1(input)
        const ret2 = step2(returnStep1)
        return new WorkflowResponse(step3({ one: returnStep1, two: ret2 }))
      })

      const workflowInput = { test: "payload1" }
      const workflowInput2 = { test: "payload2" }

      const [{ result: workflowResult }, { result: workflowResult2 }] =
        await promiseAll([
          workflow.run({
            input: workflowInput,
          }),
          workflow.run({
            input: workflowInput2,
          }),
        ])

      expect(mockStep1Fn).toHaveBeenCalledTimes(2)
      expect(mockStep1Fn.mock.calls[0]).toHaveLength(2)
      expect(mockStep1Fn.mock.calls[0][0]).toEqual(workflowInput)
      expect(mockStep1Fn.mock.calls[1]).toHaveLength(2)

      expect(mockStep2Fn).toHaveBeenCalledTimes(2)
      expect(mockStep2Fn.mock.calls[0]).toHaveLength(2)
      expect(mockStep2Fn.mock.calls[0][0]).toEqual({
        inputs: [workflowInput],
        obj: "return from 1",
      })

      expect(mockStep3Fn).toHaveBeenCalledTimes(2)
      expect(mockStep3Fn.mock.calls[0]).toHaveLength(2)
      expect(mockStep3Fn.mock.calls[0][0]).toEqual({
        one: { inputs: [{ test: "payload1" }], obj: "return from 1" },
        two: {
          inputs: [{ inputs: [{ test: "payload1" }], obj: "return from 1" }],
          obj: "return from 2",
        },
      })

      expect(workflowResult).toEqual({
        inputs: [
          {
            one: { inputs: [{ test: "payload1" }], obj: "return from 1" },
            two: {
              inputs: [
                { inputs: [{ test: "payload1" }], obj: "return from 1" },
              ],
              obj: "return from 2",
            },
          },
        ],
        obj: "return from 3",
      })
      expect(workflowResult2).toEqual({
        inputs: [
          {
            one: { inputs: [{ test: "payload2" }], obj: "return from 1" },
            two: {
              inputs: [
                { inputs: [{ test: "payload2" }], obj: "return from 1" },
              ],
              obj: "return from 2",
            },
          },
        ],
        obj: "return from 3",
      })
    })

    it("should compose a new workflow with parallelize steps", async () => {
      const mockStep1Fn = jest.fn().mockImplementation((input, context) => {
        return { inputs: [input], obj: "return from 1" }
      })
      const mockStep2Fn = jest.fn().mockImplementation((...inputs) => {
        inputs.pop()
        return {
          inputs,
          obj: "return from 2",
        }
      })
      const mockStep3Fn = jest.fn().mockImplementation((...inputs) => {
        inputs.pop()
        return {
          inputs,
          obj: "return from 3",
        }
      })
      const mockStep4Fn = jest.fn().mockImplementation((...inputs) => {
        inputs.pop()
        return {
          inputs,
          obj: "return from 4",
        }
      })

      const step1 = createStep("step1", mockStep1Fn)
      const step2 = createStep("step2", mockStep2Fn)
      const step3 = createStep("step3", mockStep3Fn)
      const step4 = createStep("step4", mockStep4Fn)

      const workflow = createWorkflow("workflow1", function (input) {
        const returnStep1 = step1(input)
        const [ret2, ret3] = parallelize(step2(returnStep1), step3(returnStep1))
        return new WorkflowResponse(step4({ one: ret2, two: ret3 }))
      })

      const workflowInput = { test: "payload1" }
      const { result: workflowResult } = await workflow.run({
        input: workflowInput,
      })

      expect(mockStep1Fn).toHaveBeenCalledTimes(1)
      expect(mockStep1Fn.mock.calls[0]).toHaveLength(2)
      expect(mockStep1Fn.mock.calls[0][0]).toEqual(workflowInput)

      expect(mockStep2Fn).toHaveBeenCalledTimes(1)
      expect(mockStep2Fn.mock.calls[0]).toHaveLength(2)
      expect(mockStep2Fn.mock.calls[0][0]).toEqual({
        inputs: [workflowInput],
        obj: "return from 1",
      })

      expect(mockStep3Fn).toHaveBeenCalledTimes(1)
      expect(mockStep3Fn.mock.calls[0]).toHaveLength(2)
      expect(mockStep3Fn.mock.calls[0][0]).toEqual({
        inputs: [workflowInput],
        obj: "return from 1",
      })

      expect(mockStep4Fn).toHaveBeenCalledTimes(1)
      expect(mockStep4Fn.mock.calls[0]).toHaveLength(2)
      expect(mockStep4Fn.mock.calls[0][0]).toEqual({
        one: {
          inputs: [{ inputs: [{ test: "payload1" }], obj: "return from 1" }],
          obj: "return from 2",
        },
        two: {
          inputs: [{ inputs: [{ test: "payload1" }], obj: "return from 1" }],
          obj: "return from 3",
        },
      })

      expect(workflowResult).toEqual({
        inputs: [
          {
            one: {
              inputs: [
                { inputs: [{ test: "payload1" }], obj: "return from 1" },
              ],
              obj: "return from 2",
            },
            two: {
              inputs: [
                { inputs: [{ test: "payload1" }], obj: "return from 1" },
              ],
              obj: "return from 3",
            },
          },
        ],
        obj: "return from 4",
      })
    })

    it("should transform the values before forward them to the next step", async () => {
      const mockStep1Fn = jest.fn().mockImplementation((obj, context) => {
        const ret = {
          property: "property",
        }
        return ret
      })

      const mockStep2Fn = jest.fn().mockImplementation((obj, context) => {
        const ret = {
          ...obj,
          sum: "sum = " + obj.sum,
        }

        return ret
      })

      const mockStep3Fn = jest.fn().mockImplementation((param, context) => {
        const ret = {
          avg: "avg = " + param.avg,
          ...param,
        }
        return ret
      })

      const transform1Fn = jest
        .fn()
        .mockImplementation(({ input, step1Result }) => {
          const newObj = {
            ...step1Result,
            ...input,
            sum: input.a + input.b,
          }
          return {
            input: newObj,
          }
        })

      const transform2Fn = jest
        .fn()
        .mockImplementation(async ({ input }, context) => {
          input.another_prop = "another_prop"
          return input
        })

      const transform3Fn = jest.fn().mockImplementation(({ obj }) => {
        obj.avg = (obj.a + obj.b) / 2

        return obj
      })

      const step1 = createStep("step1", mockStep1Fn)
      const step2 = createStep("step2", mockStep2Fn)
      const step3 = createStep("step3", mockStep3Fn)

      const mainFlow = createWorkflow("test_", function (input) {
        const step1Result = step1(input)

        const sum = transform(
          { input, step1Result },
          transform1Fn,
          transform2Fn
        )

        const ret2 = step2(sum)

        const avg = transform({ obj: ret2 }, transform3Fn)

        return new WorkflowResponse(step3(avg))
      })

      const workflowInput = { a: 1, b: 2 }
      await mainFlow.run({ input: workflowInput })

      expect(mockStep1Fn.mock.calls[0][0]).toEqual(workflowInput)

      expect(mockStep2Fn.mock.calls[0][0]).toEqual({
        property: "property",
        a: 1,
        b: 2,
        sum: 3,
        another_prop: "another_prop",
      })

      expect(mockStep3Fn.mock.calls[0][0]).toEqual({
        sum: "sum = 3",
        property: "property",
        a: 1,
        b: 2,
        another_prop: "another_prop",
        avg: 1.5,
      })

      expect(transform1Fn).toHaveBeenCalledTimes(1)
      expect(transform2Fn).toHaveBeenCalledTimes(1)
      expect(transform3Fn).toHaveBeenCalledTimes(1)
    })

    it("should compose a new workflow and access properties from steps", async () => {
      const mockStep1Fn = jest.fn().mockImplementation(({ input }, context) => {
        return { id: input, product: "product_1", variant: "variant_2" }
      })
      const mockStep2Fn = jest.fn().mockImplementation(({ product }) => {
        return {
          product: "Saved product - " + product,
        }
      })
      const mockStep3Fn = jest.fn().mockImplementation(({ variant }) => {
        return {
          variant: "Saved variant - " + variant,
        }
      })

      const getData = createStep("step1", mockStep1Fn)
      const saveProduct = createStep("step2", mockStep2Fn)
      const saveVariant = createStep("step3", mockStep3Fn)

      const workflow = createWorkflow("workflow1", function (input) {
        const data: any = getData(input)
        parallelize(
          saveProduct({ product: data.product }),
          saveVariant({ variant: data.variant })
        )
      })

      const workflowInput = "id_123"
      await workflow.run({
        input: workflowInput,
      })

      expect(mockStep1Fn).toHaveBeenCalledTimes(1)
      expect(mockStep1Fn.mock.calls[0]).toHaveLength(2)
      expect(mockStep1Fn.mock.calls[0][0]).toEqual(workflowInput)

      expect(mockStep2Fn).toHaveBeenCalledTimes(1)
      expect(mockStep2Fn.mock.calls[0]).toHaveLength(2)
      expect(mockStep2Fn.mock.calls[0][0]).toEqual({ product: "product_1" })

      expect(mockStep3Fn).toHaveBeenCalledTimes(1)
      expect(mockStep3Fn.mock.calls[0]).toHaveLength(2)
      expect(mockStep3Fn.mock.calls[0][0]).toEqual({ variant: "variant_2" })
    })

    it("should throw error when multiple handlers are defined for a single hook", async () => {
      const mockStep1Fn = jest.fn().mockImplementation(({ input }) => {
        return { id: input, product: "product_1", variant: "variant_2" }
      })

      const mockStep2Fn = jest.fn().mockImplementation(({ product }) => {
        product.product = "Saved product - " + product.product
        return product
      })

      const getData = createStep("step1", mockStep1Fn)
      const saveProduct = createStep("step2", mockStep2Fn)

      const workflow = createWorkflow("workflow1", function (input) {
        const data = getData({ input })

        const hookReturn = createHook("changeProduct", {
          opinionatedPropertyName: data,
        })

        return new WorkflowResponse(saveProduct({ product: data }), {
          hooks: [hookReturn],
        })
      })

      workflow.hooks.changeProduct(() => {})
      expect(() => workflow.hooks.changeProduct(() => {})).toThrow(
        "Cannot define multiple hook handlers for the changeProduct hook"
      )

      const workflowInput = "id_123"
      const { result: final } = await workflow.run({
        input: workflowInput,
      })

      expect(final).toEqual({
        id: "id_123",
        variant: "variant_2",
        product: "Saved product - product_1",
      })
    })
  })

  describe("Using steps returning StepResponse", function () {
    afterEach(afterEach_)

    it("should compose a new workflow composed of retryable steps", async () => {
      const maxRetries = 1

      const mockStep1Fn = jest.fn().mockImplementation((input, context) => {
        const attempt = context.metadata.attempt || 0
        if (attempt <= maxRetries) {
          throw new Error("test error")
        }

        return new StepResponse({ inputs: [input], obj: "return from 1" })
      })

      const step1 = createStep({ name: "step1", maxRetries }, mockStep1Fn)

      const workflow = createWorkflow("workflow1", function (input) {
        return new WorkflowResponse(step1(input))
      })

      const workflowInput = { test: "payload1" }
      const { result: workflowResult } = await workflow.run({
        input: workflowInput,
      })

      expect(mockStep1Fn).toHaveBeenCalledTimes(2)
      expect(mockStep1Fn.mock.calls[0]).toHaveLength(2)
      expect(mockStep1Fn.mock.calls[0][0]).toEqual(workflowInput)
      expect(mockStep1Fn.mock.calls[1][0]).toEqual(workflowInput)

      expect(workflowResult).toEqual({
        inputs: [{ test: "payload1" }],
        obj: "return from 1",
      })
    })

    it("should compose a new workflow composed of retryable steps that should stop retries on permanent failure", async () => {
      const maxRetries = 1

      const mockStep1Fn = jest.fn().mockImplementation((input, context) => {
        return StepResponse.permanentFailure("fail permanently")
      })

      const step1 = createStep({ name: "step1", maxRetries }, mockStep1Fn)

      const workflow = createWorkflow("workflow1", function (input) {
        return new WorkflowResponse(step1(input))
      })

      const workflowInput = { test: "payload1" }
      const { errors } = await workflow.run({
        input: workflowInput,
        throwOnError: false,
      })

      expect(mockStep1Fn).toHaveBeenCalledTimes(1)
      expect(mockStep1Fn.mock.calls[0]).toHaveLength(2)
      expect(mockStep1Fn.mock.calls[0][0]).toEqual(workflowInput)

      expect(errors).toHaveLength(1)
      expect(errors[0]).toEqual({
        action: "step1",
        handlerType: "invoke",
        error: expect.objectContaining({
          message: "fail permanently",
        }),
      })
    })

    it("should compose a new workflow and execute it", async () => {
      const mockStep1Fn = jest.fn().mockImplementation((input) => {
        return new StepResponse({ inputs: [input], obj: "return from 1" })
      })
      const mockStep2Fn = jest.fn().mockImplementation((...inputs) => {
        inputs.pop()
        return new StepResponse({
          inputs,
          obj: "return from 2",
        })
      })
      const mockStep3Fn = jest.fn().mockImplementation((...inputs) => {
        inputs.pop()
        return new StepResponse({
          inputs,
          obj: "return from 3",
        })
      })

      const step1 = createStep("step1", mockStep1Fn)
      const step2 = createStep("step2", mockStep2Fn)
      const step3 = createStep("step3", mockStep3Fn)

      const workflow = createWorkflow("workflow1", function (input) {
        const returnStep1 = step1(input)
        const ret2 = step2(returnStep1)
        return new WorkflowResponse(step3({ one: returnStep1, two: ret2 }))
      })

      const workflowInput = { test: "payload1" }
      const { result: workflowResult } = await workflow.run({
        input: workflowInput,
      })

      expect(mockStep1Fn).toHaveBeenCalledTimes(1)
      expect(mockStep1Fn.mock.calls[0]).toHaveLength(2)
      expect(mockStep1Fn.mock.calls[0][0]).toEqual(workflowInput)

      expect(mockStep2Fn).toHaveBeenCalledTimes(1)
      expect(mockStep2Fn.mock.calls[0]).toHaveLength(2)
      expect(mockStep2Fn.mock.calls[0][0]).toEqual({
        inputs: [workflowInput],
        obj: "return from 1",
      })

      expect(mockStep3Fn).toHaveBeenCalledTimes(1)
      expect(mockStep3Fn.mock.calls[0]).toHaveLength(2)
      expect(mockStep3Fn.mock.calls[0][0]).toEqual({
        one: {
          inputs: [workflowInput],
          obj: "return from 1",
        },
        two: {
          inputs: [
            {
              inputs: [workflowInput],
              obj: "return from 1",
            },
          ],
          obj: "return from 2",
        },
      })

      expect(workflowResult).toEqual({
        inputs: [
          {
            one: {
              inputs: [workflowInput],
              obj: "return from 1",
            },
            two: {
              inputs: [
                {
                  inputs: [workflowInput],
                  obj: "return from 1",
                },
              ],
              obj: "return from 2",
            },
          },
        ],
        obj: "return from 3",
      })
    })

    it("should compose a new workflow and skip steps depending on the input", async () => {
      const mockStep1Fn = jest.fn().mockImplementation((input) => {
        if (input === 1) {
          return StepResponse.skip()
        } else {
          return new StepResponse({ obj: "return from 1" })
        }
      })
      const mockStep2Fn = jest.fn().mockImplementation((input) => {
        if (!input) {
          return StepResponse.skip()
        }
        return new StepResponse({ obj: "return from 2" })
      })
      const mockStep3Fn = jest.fn().mockImplementation((inputs) => {
        return new StepResponse({
          inputs,
          obj: "return from 3",
        })
      })

      const step1 = createStep("step1", mockStep1Fn)
      const step2 = createStep("step2", mockStep2Fn)
      const step3 = createStep("step3", mockStep3Fn)

      const workflow = createWorkflow("workflow1", function (input) {
        const returnStep1 = step1(input)
        const ret2 = step2(returnStep1)
        return new WorkflowResponse(
          step3({ one: returnStep1, two: ret2, input })
        )
      })

      const { result: workflowResult, transaction } = await workflow.run({
        input: 1,
      })

      expect(transaction.getFlow().hasSkippedSteps).toBe(true)
      expect(mockStep3Fn.mock.calls[0][0]).toEqual({
        input: 1,
      })

      expect(workflowResult).toEqual({
        inputs: {
          input: 1,
        },
        obj: "return from 3",
      })

      const { result: workflowResultTwo, transaction: transactionTwo } =
        await workflow.run({
          input: "none",
        })

      expect(transactionTwo.getFlow().hasSkippedSteps).toBe(false)
      expect(mockStep3Fn.mock.calls[1][0]).toEqual({
        one: {
          obj: "return from 1",
        },
        two: {
          obj: "return from 2",
        },
        input: "none",
      })

      expect(workflowResultTwo).toEqual({
        inputs: {
          one: {
            obj: "return from 1",
          },
          two: {
            obj: "return from 2",
          },
          input: "none",
        },
        obj: "return from 3",
      })
    })

    it("should compose two new workflows sequentially and execute them sequentially", async () => {
      const mockStep1Fn = jest.fn().mockImplementation((input, context) => {
        return new StepResponse({ inputs: [input], obj: "return from 1" })
      })
      const mockStep2Fn = jest.fn().mockImplementation((...inputs) => {
        inputs.pop()
        return new StepResponse({
          inputs,
          obj: "return from 2",
        })
      })
      const mockStep3Fn = jest.fn().mockImplementation((...inputs) => {
        inputs.pop()
        return new StepResponse({
          inputs,
          obj: "return from 3",
        })
      })

      const step1 = createStep("step1", mockStep1Fn)
      const step2 = createStep("step2", mockStep2Fn)
      const step3 = createStep("step3", mockStep3Fn)

      const workflow = createWorkflow("workflow1", function (input) {
        const returnStep1 = step1(input)
        const ret2 = step2(returnStep1)
        return new WorkflowResponse(step3({ one: returnStep1, two: ret2 }))
      })

      const workflow2 = createWorkflow("workflow2", function (input) {
        const returnStep1 = step1(input)
        const ret2 = step2(returnStep1)
        return new WorkflowResponse(step3({ one: returnStep1, two: ret2 }))
      })

      const workflowInput = { test: "payload1" }
      const { result: workflowResult } = await workflow.run({
        input: workflowInput,
      })

      const workflow2Input = { test: "payload2" }
      const { result: workflow2Result } = await workflow2.run({
        input: workflow2Input,
      })

      expect(mockStep1Fn).toHaveBeenCalledTimes(2)
      expect(mockStep1Fn.mock.calls[0]).toHaveLength(2)
      expect(mockStep1Fn.mock.calls[0][0]).toEqual(workflowInput)
      expect(mockStep1Fn.mock.calls[1][0]).toEqual(workflow2Input)

      expect(mockStep2Fn).toHaveBeenCalledTimes(2)
      expect(mockStep2Fn.mock.calls[0]).toHaveLength(2)
      expect(mockStep2Fn.mock.calls[0][0]).toEqual({
        inputs: [{ test: "payload1" }],
        obj: "return from 1",
      })
      expect(mockStep2Fn.mock.calls[1][0]).toEqual({
        inputs: [{ test: "payload2" }],
        obj: "return from 1",
      })

      expect(mockStep3Fn).toHaveBeenCalledTimes(2)
      expect(mockStep3Fn.mock.calls[0]).toHaveLength(2)
      expect(mockStep3Fn.mock.calls[0][0]).toEqual({
        one: { inputs: [{ test: "payload1" }], obj: "return from 1" },
        two: {
          inputs: [{ inputs: [{ test: "payload1" }], obj: "return from 1" }],
          obj: "return from 2",
        },
      })
      expect(mockStep3Fn.mock.calls[1][0]).toEqual({
        one: { inputs: [{ test: "payload2" }], obj: "return from 1" },
        two: {
          inputs: [{ inputs: [{ test: "payload2" }], obj: "return from 1" }],
          obj: "return from 2",
        },
      })

      expect(workflowResult).toEqual({
        inputs: [
          {
            one: { inputs: [{ test: "payload1" }], obj: "return from 1" },
            two: {
              inputs: [
                { inputs: [{ test: "payload1" }], obj: "return from 1" },
              ],
              obj: "return from 2",
            },
          },
        ],
        obj: "return from 3",
      })
      expect(workflow2Result).toEqual({
        inputs: [
          {
            one: { inputs: [{ test: "payload2" }], obj: "return from 1" },
            two: {
              inputs: [
                { inputs: [{ test: "payload2" }], obj: "return from 1" },
              ],
              obj: "return from 2",
            },
          },
        ],
        obj: "return from 3",
      })
    })

    it("should compose two new workflows concurrently and execute them sequentially", async () => {
      const mockStep1Fn = jest.fn().mockImplementation((input, context) => {
        return new StepResponse({ inputs: [input], obj: "return from 1" })
      })
      const mockStep2Fn = jest.fn().mockImplementation((...inputs) => {
        inputs.pop()
        return new StepResponse({
          inputs,
          obj: "return from 2",
        })
      })
      const mockStep3Fn = jest.fn().mockImplementation((...inputs) => {
        inputs.pop()
        return new StepResponse({
          inputs,
          obj: "return from 3",
        })
      })

      const step1 = createStep("step1", mockStep1Fn)
      const step2 = createStep("step2", mockStep2Fn)
      const step3 = createStep("step3", mockStep3Fn)

      const [workflow, workflow2] = await promiseAll([
        createWorkflow("workflow1", function (input) {
          const returnStep1 = step1(input)
          const ret2 = step2(returnStep1)
          return new WorkflowResponse(step3({ one: returnStep1, two: ret2 }))
        }),

        createWorkflow("workflow2", function (input) {
          const returnStep1 = step1(input)
          const ret2 = step2(returnStep1)
          return new WorkflowResponse(step3({ one: returnStep1, two: ret2 }))
        }),
      ])

      const workflowInput = { test: "payload1" }
      const { result: workflowResult } = await workflow.run({
        input: workflowInput,
      })

      const workflow2Input = { test: "payload2" }
      const { result: workflow2Result } = await workflow2.run({
        input: workflow2Input,
      })

      expect(mockStep1Fn).toHaveBeenCalledTimes(2)
      expect(mockStep1Fn.mock.calls[0]).toHaveLength(2)
      expect(mockStep1Fn.mock.calls[0][0]).toEqual(workflowInput)
      expect(mockStep1Fn.mock.calls[1][0]).toEqual(workflow2Input)

      expect(mockStep2Fn).toHaveBeenCalledTimes(2)
      expect(mockStep2Fn.mock.calls[0]).toHaveLength(2)
      expect(mockStep2Fn.mock.calls[0][0]).toEqual({
        inputs: [workflowInput],
        obj: "return from 1",
      })
      expect(mockStep2Fn.mock.calls[1][0]).toEqual({
        inputs: [workflow2Input],
        obj: "return from 1",
      })

      expect(mockStep3Fn).toHaveBeenCalledTimes(2)
      expect(mockStep3Fn.mock.calls[0]).toHaveLength(2)
      expect(mockStep3Fn.mock.calls[0][0]).toEqual({
        one: { inputs: [{ test: "payload1" }], obj: "return from 1" },
        two: {
          inputs: [{ inputs: [{ test: "payload1" }], obj: "return from 1" }],
          obj: "return from 2",
        },
      })
      expect(mockStep3Fn.mock.calls[1][0]).toEqual({
        one: { inputs: [{ test: "payload2" }], obj: "return from 1" },
        two: {
          inputs: [{ inputs: [{ test: "payload2" }], obj: "return from 1" }],
          obj: "return from 2",
        },
      })

      expect(workflowResult).toEqual({
        inputs: [
          {
            one: { inputs: [{ test: "payload1" }], obj: "return from 1" },
            two: {
              inputs: [
                { inputs: [{ test: "payload1" }], obj: "return from 1" },
              ],
              obj: "return from 2",
            },
          },
        ],
        obj: "return from 3",
      })
      expect(workflow2Result).toEqual({
        inputs: [
          {
            one: { inputs: [{ test: "payload2" }], obj: "return from 1" },
            two: {
              inputs: [
                { inputs: [{ test: "payload2" }], obj: "return from 1" },
              ],
              obj: "return from 2",
            },
          },
        ],
        obj: "return from 3",
      })
    })

    it("should compose two new workflows concurrently and execute them concurrently", async () => {
      const mockStep1Fn = jest.fn().mockImplementation((input, context) => {
        return new StepResponse({ inputs: [input], obj: "return from 1" })
      })
      const mockStep2Fn = jest.fn().mockImplementation((...inputs) => {
        inputs.pop()
        return new StepResponse({
          inputs,
          obj: "return from 2",
        })
      })
      const mockStep3Fn = jest.fn().mockImplementation((...inputs) => {
        inputs.pop()
        return new StepResponse({
          inputs,
          obj: "return from 3",
        })
      })

      const step1 = createStep("step1", mockStep1Fn)
      const step2 = createStep("step2", mockStep2Fn)
      const step3 = createStep("step3", mockStep3Fn)

      const [workflow, workflow2] = await promiseAll([
        createWorkflow("workflow1", function (input) {
          const returnStep1 = step1(input)
          const ret2 = step2(returnStep1)
          return new WorkflowResponse(step3({ one: returnStep1, two: ret2 }))
        }),

        createWorkflow("workflow2", function (input) {
          const returnStep1 = step1(input)
          const ret2 = step2(returnStep1)
          return new WorkflowResponse(step3({ one: returnStep1, two: ret2 }))
        }),
      ])

      const workflowInput = { test: "payload1" }
      const workflow2Input = { test: "payload2" }

      const [{ result: workflowResult }, { result: workflow2Result }] =
        await promiseAll([
          workflow.run({
            input: workflowInput,
          }),
          workflow2.run({
            input: workflow2Input,
          }),
        ])

      expect(mockStep1Fn).toHaveBeenCalledTimes(2)
      expect(mockStep1Fn.mock.calls[0]).toHaveLength(2)
      expect(mockStep1Fn.mock.calls[0][0]).toEqual(workflowInput)
      expect(mockStep1Fn.mock.calls[1][0]).toEqual(workflow2Input)
      expect(mockStep1Fn.mock.calls[1]).toHaveLength(2)

      expect(mockStep2Fn).toHaveBeenCalledTimes(2)
      expect(mockStep2Fn.mock.calls[0]).toHaveLength(2)
      expect(mockStep2Fn.mock.calls[0][0]).toEqual({
        inputs: [workflowInput],
        obj: "return from 1",
      })
      expect(mockStep2Fn.mock.calls[1][0]).toEqual({
        inputs: [workflow2Input],
        obj: "return from 1",
      })

      expect(mockStep3Fn).toHaveBeenCalledTimes(2)
      expect(mockStep3Fn.mock.calls[0]).toHaveLength(2)
      expect(mockStep3Fn.mock.calls[0][0]).toEqual({
        one: { inputs: [{ test: "payload1" }], obj: "return from 1" },
        two: {
          inputs: [{ inputs: [{ test: "payload1" }], obj: "return from 1" }],
          obj: "return from 2",
        },
      })
      expect(mockStep3Fn.mock.calls[1][0]).toEqual({
        one: { inputs: [{ test: "payload2" }], obj: "return from 1" },
        two: {
          inputs: [{ inputs: [{ test: "payload2" }], obj: "return from 1" }],
          obj: "return from 2",
        },
      })

      expect(workflowResult).toEqual({
        inputs: [
          {
            one: { inputs: [{ test: "payload1" }], obj: "return from 1" },
            two: {
              inputs: [
                { inputs: [{ test: "payload1" }], obj: "return from 1" },
              ],
              obj: "return from 2",
            },
          },
        ],
        obj: "return from 3",
      })
      expect(workflow2Result).toEqual({
        inputs: [
          {
            one: { inputs: [{ test: "payload2" }], obj: "return from 1" },
            two: {
              inputs: [
                { inputs: [{ test: "payload2" }], obj: "return from 1" },
              ],
              obj: "return from 2",
            },
          },
        ],
        obj: "return from 3",
      })
    })

    it("should compose a new workflow and execute it multiple times concurrently", async () => {
      const mockStep1Fn = jest
        .fn()
        .mockImplementation(function (input, context) {
          return new StepResponse({ inputs: [input], obj: "return from 1" })
        })
      const mockStep2Fn = jest.fn().mockImplementation(function (...inputs) {
        inputs.pop()
        return new StepResponse({
          inputs,
          obj: "return from 2",
        })
      })
      const mockStep3Fn = jest.fn().mockImplementation(function (...inputs) {
        inputs.pop()
        return new StepResponse({
          inputs,
          obj: "return from 3",
        })
      })

      const step1 = createStep("step1", mockStep1Fn)
      const step2 = createStep("step2", mockStep2Fn)
      const step3 = createStep("step3", mockStep3Fn)

      const workflow = createWorkflow("workflow1", function (input) {
        const returnStep1 = step1(input)
        const ret2 = step2(returnStep1)
        return new WorkflowResponse(step3({ one: returnStep1, two: ret2 }))
      })

      const workflowInput = { test: "payload1" }
      const workflowInput2 = { test: "payload2" }

      const [{ result: workflowResult }, { result: workflowResult2 }] =
        await promiseAll([
          workflow.run({
            input: workflowInput,
          }),
          workflow.run({
            input: workflowInput2,
          }),
        ])

      expect(mockStep1Fn).toHaveBeenCalledTimes(2)
      expect(mockStep1Fn.mock.calls[0]).toHaveLength(2)
      expect(mockStep1Fn.mock.calls[0][0]).toEqual(workflowInput)
      expect(mockStep1Fn.mock.calls[1]).toHaveLength(2)

      expect(mockStep2Fn).toHaveBeenCalledTimes(2)
      expect(mockStep2Fn.mock.calls[0]).toHaveLength(2)
      expect(mockStep2Fn.mock.calls[0][0]).toEqual({
        inputs: [workflowInput],
        obj: "return from 1",
      })

      expect(mockStep3Fn).toHaveBeenCalledTimes(2)
      expect(mockStep3Fn.mock.calls[0]).toHaveLength(2)
      expect(mockStep3Fn.mock.calls[0][0]).toEqual({
        one: { inputs: [{ test: "payload1" }], obj: "return from 1" },
        two: {
          inputs: [{ inputs: [{ test: "payload1" }], obj: "return from 1" }],
          obj: "return from 2",
        },
      })

      expect(workflowResult).toEqual({
        inputs: [
          {
            one: { inputs: [{ test: "payload1" }], obj: "return from 1" },
            two: {
              inputs: [
                { inputs: [{ test: "payload1" }], obj: "return from 1" },
              ],
              obj: "return from 2",
            },
          },
        ],
        obj: "return from 3",
      })
      expect(workflowResult2).toEqual({
        inputs: [
          {
            one: { inputs: [{ test: "payload2" }], obj: "return from 1" },
            two: {
              inputs: [
                { inputs: [{ test: "payload2" }], obj: "return from 1" },
              ],
              obj: "return from 2",
            },
          },
        ],
        obj: "return from 3",
      })
    })

    it("should compose a new workflow with parallelize steps", async () => {
      const mockStep1Fn = jest.fn().mockImplementation((input, context) => {
        return new StepResponse({ inputs: [input], obj: "return from 1" })
      })
      const mockStep2Fn = jest.fn().mockImplementation((...inputs) => {
        inputs.pop()
        return new StepResponse({
          inputs,
          obj: "return from 2",
        })
      })
      const mockStep3Fn = jest.fn().mockImplementation((...inputs) => {
        inputs.pop()
        return new StepResponse({
          inputs,
          obj: "return from 3",
        })
      })
      const mockStep4Fn = jest.fn().mockImplementation((...inputs) => {
        inputs.pop()
        return {
          inputs,
          obj: "return from 4",
        }
      })

      const step1 = createStep("step1", mockStep1Fn)
      const step2 = createStep("step2", mockStep2Fn)
      const step3 = createStep("step3", mockStep3Fn)
      const step4 = createStep("step4", mockStep4Fn)

      const workflow = createWorkflow("workflow1", function (input) {
        const returnStep1 = step1(input)
        const [ret2, ret3] = parallelize(step2(returnStep1), step3(returnStep1))
        return new WorkflowResponse(step4({ one: ret2, two: ret3 }))
      })

      const workflowInput = { test: "payload1" }
      const { result: workflowResult } = await workflow.run({
        input: workflowInput,
      })

      expect(mockStep1Fn).toHaveBeenCalledTimes(1)
      expect(mockStep1Fn.mock.calls[0]).toHaveLength(2)
      expect(mockStep1Fn.mock.calls[0][0]).toEqual(workflowInput)

      expect(mockStep2Fn).toHaveBeenCalledTimes(1)
      expect(mockStep2Fn.mock.calls[0]).toHaveLength(2)
      expect(mockStep2Fn.mock.calls[0][0]).toEqual({
        inputs: [workflowInput],
        obj: "return from 1",
      })

      expect(mockStep3Fn).toHaveBeenCalledTimes(1)
      expect(mockStep3Fn.mock.calls[0]).toHaveLength(2)
      expect(mockStep3Fn.mock.calls[0][0]).toEqual({
        inputs: [workflowInput],
        obj: "return from 1",
      })

      expect(mockStep4Fn).toHaveBeenCalledTimes(1)
      expect(mockStep4Fn.mock.calls[0]).toHaveLength(2)
      expect(mockStep4Fn.mock.calls[0][0]).toEqual({
        one: {
          inputs: [{ inputs: [{ test: "payload1" }], obj: "return from 1" }],
          obj: "return from 2",
        },
        two: {
          inputs: [{ inputs: [{ test: "payload1" }], obj: "return from 1" }],
          obj: "return from 3",
        },
      })

      expect(workflowResult).toEqual({
        inputs: [
          {
            one: {
              inputs: [
                { inputs: [{ test: "payload1" }], obj: "return from 1" },
              ],
              obj: "return from 2",
            },
            two: {
              inputs: [
                { inputs: [{ test: "payload1" }], obj: "return from 1" },
              ],
              obj: "return from 3",
            },
          },
        ],
        obj: "return from 4",
      })
    })

    it("should transform the values before forward them to the next step", async () => {
      const mockStep1Fn = jest.fn().mockImplementation((obj, context) => {
        const ret = new StepResponse({
          property: "property",
        })
        return ret
      })

      const mockStep2Fn = jest.fn().mockImplementation((obj, context) => {
        const ret = new StepResponse({
          ...obj,
          sum: "sum = " + obj.sum,
        })

        return ret
      })

      const mockStep3Fn = jest.fn().mockImplementation((param, context) => {
        const ret = new StepResponse({
          avg: "avg = " + param.avg,
          ...param,
        })
        return ret
      })

      const transform1Fn = jest
        .fn()
        .mockImplementation(({ input, step1Result }) => {
          const newObj = {
            ...step1Result,
            ...input,
            sum: input.a + input.b,
          }
          return {
            input: newObj,
          }
        })

      const transform2Fn = jest
        .fn()
        .mockImplementation(async ({ input }, context) => {
          input.another_prop = "another_prop"
          return input
        })

      const transform3Fn = jest.fn().mockImplementation(({ obj }) => {
        obj.avg = (obj.a + obj.b) / 2

        return obj
      })

      const step1 = createStep("step1", mockStep1Fn)
      const step2 = createStep("step2", mockStep2Fn)
      const step3 = createStep("step3", mockStep3Fn)

      const mainFlow = createWorkflow("test_", function (input) {
        const step1Result = step1(input)

        const sum = transform(
          { input, step1Result },
          transform1Fn,
          transform2Fn
        )

        const ret2 = step2(sum)

        const avg = transform({ obj: ret2 }, transform3Fn)

        return new WorkflowResponse(step3(avg))
      })

      const workflowInput = { a: 1, b: 2 }
      await mainFlow.run({ input: workflowInput })

      expect(mockStep1Fn.mock.calls[0][0]).toEqual(workflowInput)

      expect(mockStep2Fn.mock.calls[0][0]).toEqual({
        property: "property",
        a: 1,
        b: 2,
        sum: 3,
        another_prop: "another_prop",
      })

      expect(mockStep3Fn.mock.calls[0][0]).toEqual({
        sum: "sum = 3",
        property: "property",
        a: 1,
        b: 2,
        another_prop: "another_prop",
        avg: 1.5,
      })

      expect(transform1Fn).toHaveBeenCalledTimes(1)
      expect(transform2Fn).toHaveBeenCalledTimes(1)
      expect(transform3Fn).toHaveBeenCalledTimes(1)
    })

    it("should compose a new workflow and access properties from steps", async () => {
      const mockStep1Fn = jest.fn().mockImplementation(({ input }, context) => {
        return new StepResponse({
          id: input,
          product: "product_1",
          variant: "variant_2",
        })
      })
      const mockStep2Fn = jest.fn().mockImplementation(({ product }) => {
        return new StepResponse({
          product: "Saved product - " + product,
        })
      })
      const mockStep3Fn = jest.fn().mockImplementation(({ variant }) => {
        return new StepResponse({
          variant: "Saved variant - " + variant,
        })
      })

      const getData = createStep("step1", mockStep1Fn)
      const saveProduct = createStep("step2", mockStep2Fn)
      const saveVariant = createStep("step3", mockStep3Fn)

      const workflow = createWorkflow("workflow1", function (input) {
        const data: any = getData(input)
        parallelize(
          saveProduct({ product: data.product }),
          saveVariant({ variant: data.variant })
        )
      })

      const workflowInput = "id_123"
      await workflow.run({
        input: workflowInput,
      })

      expect(mockStep1Fn).toHaveBeenCalledTimes(1)
      expect(mockStep1Fn.mock.calls[0]).toHaveLength(2)
      expect(mockStep1Fn.mock.calls[0][0]).toEqual(workflowInput)

      expect(mockStep2Fn).toHaveBeenCalledTimes(1)
      expect(mockStep2Fn.mock.calls[0]).toHaveLength(2)
      expect(mockStep2Fn.mock.calls[0][0]).toEqual({ product: "product_1" })

      expect(mockStep3Fn).toHaveBeenCalledTimes(1)
      expect(mockStep3Fn.mock.calls[0]).toHaveLength(2)
      expect(mockStep3Fn.mock.calls[0][0]).toEqual({ variant: "variant_2" })
    })

    it("should throw error when multiple handlers for the same hook are defined", async () => {
      const mockStep1Fn = jest.fn().mockImplementation(({ input }) => {
        return new StepResponse({
          id: input,
          product: "product_1",
          variant: "variant_2",
        })
      })

      const mockStep2Fn = jest.fn().mockImplementation(({ product }) => {
        product.product = "Saved product - " + product.product
        return new StepResponse(product)
      })

      const getData = createStep("step1", mockStep1Fn)
      const saveProduct = createStep("step2", mockStep2Fn)

      const workflow = createWorkflow("workflow1", function (input) {
        const data = getData({ input })

        const hookReturn = createHook("changeProduct", {
          opinionatedPropertyName: data,
        })

        return new WorkflowResponse(saveProduct({ product: data }), {
          hooks: [hookReturn],
        })
      })

      workflow.hooks.changeProduct(() => {})
      expect(() => workflow.hooks.changeProduct(() => {})).toThrow(
        "Cannot define multiple hook handlers for the changeProduct hook"
      )

      const workflowInput = "id_123"
      const { result: final } = await workflow.run({
        input: workflowInput,
      })

      expect(final).toEqual({
        id: "id_123",
        variant: "variant_2",
        product: "Saved product - product_1",
      })
    })
  })

  it("should compose a workflow that throws without crashing and the compensation will receive undefined for the step that fails", async () => {
    const mockStep1Fn = jest.fn().mockImplementation(function (input) {
      throw new Error("invoke fail")
    })

    const mockCompensateSte1 = jest.fn().mockImplementation(function (input) {
      return input
    })

    const step1 = createStep("step1", mockStep1Fn, mockCompensateSte1)

    const workflow = createWorkflow("workflow1", function (input) {
      return new WorkflowResponse(step1(input))
    })

    const workflowInput = { test: "payload1" }
    const { errors } = await workflow.run({
      input: workflowInput,
      throwOnError: false,
    })

    expect(errors).toHaveLength(1)
    expect(errors[0]).toEqual({
      action: "step1",
      handlerType: "invoke",
      error: expect.objectContaining({
        message: "invoke fail",
      }),
    })

    expect(mockStep1Fn).toHaveBeenCalledTimes(1)
    expect(mockCompensateSte1).toHaveBeenCalledTimes(1)

    expect(mockStep1Fn.mock.calls[0][0]).toEqual(workflowInput)
    expect(mockCompensateSte1.mock.calls[0][0]).toEqual(undefined)
  })

  it("should compose a workflow that returns destructured properties", async () => {
    const step = function () {
      return new StepResponse({
        propertyNotReturned: 1234,
        property: {
          complex: {
            nested: 123,
          },
          a: "bc",
        },
        obj: "return from 2",
      })
    }

    const step1 = createStep("step1", step)

    const workflow = createWorkflow("workflow1", function () {
      const { property, obj } = step1()

      return new WorkflowResponse({ someOtherName: property, obj })
    })

    const { result } = await workflow.run({
      throwOnError: false,
    })

    expect(result).toEqual({
      someOtherName: {
        complex: {
          nested: 123,
        },
        a: "bc",
      },
      obj: "return from 2",
    })
  })

  it("should compose a workflow that returns an array of steps", async () => {
    const step1 = createStep("step1", () => {
      return new StepResponse({
        obj: "return from 1",
      })
    })
    const step2 = createStep("step2", () => {
      return new StepResponse({
        obj: "returned from 2**",
      })
    })

    const workflow = createWorkflow("workflow1", function () {
      const s1 = step1()
      const s2 = step2()

      return new WorkflowResponse([s1, s2])
    })

    const { result } = await workflow.run({
      throwOnError: false,
    })

    expect(result).toEqual([
      {
        obj: "return from 1",
      },
      {
        obj: "returned from 2**",
      },
    ])
  })

  it("should compose a workflow that returns an object mixed of steps and properties", async () => {
    const step1 = createStep("step1", () => {
      return new StepResponse({
        obj: {
          nested: "nested",
        },
      })
    })

    const step2 = createStep("step2", () => {
      return new StepResponse({
        obj: "returned from 2**",
      })
    })

    const workflow = createWorkflow("workflow1", function () {
      const { obj } = step1()
      const s2 = step2()

      return new WorkflowResponse([{ step1_nested_obj: obj.nested }, s2])
    })

    const { result } = await workflow.run({
      throwOnError: false,
    })

    expect(result).toEqual([
      {
        step1_nested_obj: "nested",
      },
      {
        obj: "returned from 2**",
      },
    ])
  })

  it("should cancel the workflow after completed", async () => {
    const mockStep1Fn = jest.fn().mockImplementation(function (input) {
      return new StepResponse({ obj: "return from 1" }, { data: "data" })
    })

    const mockCompensateSte1 = jest.fn().mockImplementation(function (input) {
      return input
    })

    const step1 = createStep("step1", mockStep1Fn, mockCompensateSte1)

    const workflow = createWorkflow("workflow1", function (input) {
      return new WorkflowResponse(step1(input))
    })

    const workflowInput = { test: "payload1" }
    const { transaction } = await workflow.run({
      input: workflowInput,
      throwOnError: false,
    })

    expect(mockStep1Fn).toHaveBeenCalledTimes(1)
    expect(mockCompensateSte1).toHaveBeenCalledTimes(0)

    await workflow.cancel({
      transaction,
      throwOnError: false,
    })

    expect(mockStep1Fn).toHaveBeenCalledTimes(1)
    expect(mockCompensateSte1).toHaveBeenCalledTimes(1)

    expect(mockStep1Fn.mock.calls[0][0]).toEqual(workflowInput)
    expect(mockCompensateSte1.mock.calls[0][0]).toEqual({ data: "data" })
  })

  it("should throw if the same workflow is defined using different steps", async () => {
    const step1 = createStep("step1", () => {
      return new StepResponse({
        obj: {
          nested: "nested",
        },
      })
    })

    const step2 = createStep("step2", () => {
      return new StepResponse({
        obj: "returned from 2**",
      })
    })

    const step3 = createStep("step3", () => {
      return new StepResponse({
        obj: "returned from 3**",
      })
    })

    createWorkflow("workflow1", function () {
      const { obj } = step1()
      const s2 = step2()

      return new WorkflowResponse([{ step1_nested_obj: obj.nested }, s2])
    })

    expect(() =>
      createWorkflow("workflow1", function () {
        const { obj } = step1()
        const s2 = step2()
        step3()

        return new WorkflowResponse([{ step1_nested_obj: obj.nested }, s2])
      })
    ).toThrowError(
      `Workflow with id "workflow1" and step definition already exists.`
    )

    createWorkflow("workflow1", function () {
      const { obj } = step1()
      const s2 = step2()

      return new WorkflowResponse([{ step1_nested_obj: obj.nested }, s2])
    })
  })

  it("should emit grouped events once the workflow is executed and finished", async () => {
    const container = createMedusaContainer()
    container.register({
      [Modules.EVENT_BUS]: asValue({
        releaseGroupedEvents: jest
          .fn()
          .mockImplementation(() => Promise.resolve()),
        emit: jest.fn(),
      }),
    })

    const mockStep1Fn = jest
      .fn()
      .mockImplementation(
        async (input, { context: stepContext, container }) => {
          const eventBusService = container.resolve(Modules.EVENT_BUS)

          await eventBusService.emit(
            "event1",
            composeMessage("event1", {
              data: { eventGroupId: stepContext.eventGroupId },
              context: stepContext,
              object: "object",
              source: "service",
              action: "action",
            })
          )
        }
      )

    const step1 = createStep("step1", mockStep1Fn)

    const workflow = createWorkflow("workflow1", function (input) {
      step1(input)
    })

    await workflow.run({
      container,
      context: {
        eventGroupId: "event-group-id",
      },
    })

    expect(mockStep1Fn).toHaveBeenCalledTimes(1)
    expect(mockStep1Fn.mock.calls[0]).toHaveLength(2)

    const eventBusMock = container.resolve<
      IEventBusModuleService & {
        emit: jest.Mock<any, any, any>
        releaseGroupedEvents: jest.Mock<any, any, any>
      }
    >(Modules.EVENT_BUS)
    expect(eventBusMock.emit).toHaveBeenCalledTimes(1)
    expect(eventBusMock.emit.mock.calls[0][0]).toEqual("event1")

    expect(eventBusMock.releaseGroupedEvents).toHaveBeenCalledTimes(1)
    expect(eventBusMock.releaseGroupedEvents.mock.calls[0][0]).toEqual(
      "event-group-id"
    )
  })

  it("should clear grouped events on fail state", async () => {
    const container = createMedusaContainer()
    container.register({
      [Modules.EVENT_BUS]: asValue({
        releaseGroupedEvents: jest
          .fn()
          .mockImplementation(() => Promise.resolve()),
        clearGroupedEvents: jest
          .fn()
          .mockImplementation(() => Promise.resolve()),
        emit: jest.fn(),
      }),
    })

    const mockStep1Fn = jest
      .fn()
      .mockImplementation(
        async (input, { context: stepContext, container }) => {
          const eventBusService = container.resolve(Modules.EVENT_BUS)

          await eventBusService.emit(
            "event1",
            composeMessage("event1", {
              data: { eventGroupId: stepContext.eventGroupId },
              context: stepContext,
              object: "object",
              source: "service",
              action: "action",
            })
          )
        }
      )

    const mockStep2Fn = jest.fn().mockImplementation(() => {
      throw new Error("invoke fail")
    })

    const step1 = createStep("step1", mockStep1Fn)
    const step2 = createStep("step2", mockStep2Fn)

    const workflow = createWorkflow("workflow1", function (input) {
      step1(input)
      step2(input)
    })

    await workflow.run({
      container,
      context: {
        eventGroupId: "event-group-id",
      },
      throwOnError: false,
    })

    const eventBusMock = container.resolve<IEventBusModuleService>(
      Modules.EVENT_BUS
    )

    expect(eventBusMock.emit).toHaveBeenCalledTimes(1)
    expect(eventBusMock.releaseGroupedEvents).toHaveBeenCalledTimes(0)
    expect(eventBusMock.clearGroupedEvents).toHaveBeenCalledTimes(1)
    expect(eventBusMock.clearGroupedEvents).toHaveBeenCalledWith(
      "event-group-id"
    )
  })
})
